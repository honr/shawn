ccmake version 2.4-patch 6
------------------------------------------------------------------------------
Name

  ccmake - Curses Interface for CMake.

------------------------------------------------------------------------------
Usage

  ccmake <path-to-source>
  ccmake <path-to-existing-build>

The "ccmake" executable is the CMake curses interface.  Project configuration
settings may be specified interactively through this GUI.  Brief instructions
are provided at the bottom of the terminal when the program is running.

CMake is a cross-platform build system generator.  Projects specify their
build process with platform-independent CMake listfiles included in each
directory of a source tree with the name CMakeLists.txt.  Users build a
project by using CMake to generate a build system for a native tool on their
platform.

------------------------------------------------------------------------------
Command-Line Options

  -C <initial-cache>
       Pre-load a script to populate the cache.

       When cmake is first run in an empty build tree, it creates a
       CMakeCache.txt file and populates it with customizable settings for
       the project.  This option may be used to specify a file from which to
       load cache entries before the first pass through the project's cmake
       listfiles.  The loaded entries take priority over the project's
       default values.  The given file should be a CMake script containing
       SET commands that use the CACHE option, not a cache-format file.

  -D <var>:<type>=<value>
       Create a cmake cache entry.

       When cmake is first run in an empty build tree, it creates a
       CMakeCache.txt file and populates it with customizable settings for
       the project.  This option may be used to specify a setting that takes
       priority over the project's default value.  The option may be repeated
       for as many cache entries as desired.

  -G <generator-name>
       Specify a makefile generator.

       CMake may support multiple native build systems on certain platforms.
       A makefile generator is responsible for generating a particular build
       system.  Possible generator names are specified in the Generators
       section.

  --copyright [file]
       Print the CMake copyright and exit.

       If a file is specified, the copyright is written into it.

  --help
       Print usage information and exit.

       Usage describes the basic command line interface and its options.

  --help-full [file]
       Print full help and exit.

       Full help displays most of the documentation provided by the UNIX man
       page.  It is provided for use on non-UNIX platforms, but is also
       convenient if the man page is not installed.  If a file is specified,
       the help is written into it.

  --help-html [file]
       Print full help in HTML format.

       This option is used by CMake authors to help produce web pages.  If a
       file is specified, the help is written into it.

  --help-man [file]
       Print a UNIX man page and exit.

       This option is used by the cmake build to generate the UNIX man page.
       If a file is specified, the help is written into it.

  --version [file]
       Show program name/version banner and exit.

       If a file is specified, the version is written into it.

------------------------------------------------------------------------------
Generators

The following generators are available on this platform:

  KDevelop3
       Generates KDevelop 3 project files.

       Project files for KDevelop 3 will be created in the top directory and
       in every subdirectory which features a CMakeLists.txt file containing
       a PROJECT() call.  If you change the settings using KDevelop cmake
       will try its best to keep your changes when regenerating the project
       files.  Additionally a hierarchy of UNIX makefiles is generated into
       the build tree.  Any standard UNIX-style make program can build the
       project through the default make target.  A "make install" target is
       also provided.

  Unix Makefiles
       Generates standard UNIX makefiles.

       A hierarchy of UNIX makefiles is generated into the build tree.  Any
       standard UNIX-style make program can build the project through the
       default make target.  A "make install" target is also provided.

  Xcode
       Generate XCode project files.


------------------------------------------------------------------------------
Listfile Commands

The following commands are available in CMakeLists.txt code:

  ADD_CUSTOM_COMMAND
       Add a custom build rule to the generated build system.

       There are two main signatures for ADD_CUSTOM_COMMAND The first
       signature is for adding a custom command to produce an output.

         ADD_CUSTOM_COMMAND(OUTPUT output1 [output2 ...]
                            COMMAND command1 [ARGS] [args1...]
                            [COMMAND command2 [ARGS] [args2...] ...]
                            [MAIN_DEPENDENCY depend]
                            [DEPENDS [depends...]]
                            [WORKING_DIRECTORY dir]
                            [COMMENT comment] [VERBATIM] [APPEND])

       This defines a new command that can be executed during the build
       process.  The outputs named should be listed as source files in the
       target for which they are to be generated.  Note that MAIN_DEPENDENCY
       is completely optional and is used as a suggestion to visual studio
       about where to hang the custom command.  In makefile terms this
       creates a new target in the following form:

         OUTPUT: MAIN_DEPENDENCY DEPENDS
                 COMMAND

       If more than one command is specified they will be executed in order.
       The optional ARGS argument is for backward compatibility and will be
       ignored.

       The second signature adds a custom command to a target such as a
       library or executable.  This is useful for performing an operation
       before or after building the target:

         ADD_CUSTOM_COMMAND(TARGET target
                            PRE_BUILD | PRE_LINK | POST_BUILD
                            COMMAND command1 [ARGS] [args1...]
                            [COMMAND command2 [ARGS] [args2...] ...]
                            [WORKING_DIRECTORY dir]
                            [COMMENT comment] [VERBATIM])

       This defines a new command that will be associated with building the
       specified target.  When the command will happen is determined by which
       of the following is specified:

         PRE_BUILD - run before all other dependencies
         PRE_LINK - run after other dependencies
         POST_BUILD - run after the target has been built

       Note that the PRE_BUILD option is only supported on Visual Studio 7 or
       later.  For all other generators PRE_BUILD will be treated as
       PRE_LINK.

       If WORKING_DIRECTORY is specified the command will be executed in the
       directory given.  If COMMENT is set, the value will be displayed as a
       message before the commands are executed at build time.  If APPEND is
       specified the COMMAND and DEPENDS option values are appended to the
       custom command for the first output specified.  There must have
       already been a previous call to this command with the same output.
       The COMMENT, WORKING_DIRECTORY, and MAIN_DEPENDENCY options are
       currently ignored when APPEND is given, but may be used in the future.

       If VERBATIM is given then all the arguments to the commands will be
       passed exactly as specified no matter the build tool used.  Note that
       one level of escapes is still used by the CMake language processor
       before ADD_CUSTOM_TARGET even sees the arguments.  Use of VERBATIM is
       recommended as it enables correct behavior.  When VERBATIM is not
       given the behavior is platform specific.  In the future VERBATIM may
       be enabled by default.  The only reason it is an option is to preserve
       compatibility with older CMake code.

       If the output of the custom command is not actually created as a file
       on disk it should be marked as SYMBOLIC with
       SET_SOURCE_FILES_PROPERTIES.

  ADD_CUSTOM_TARGET
       Add a target with no output so it will always be built.

         ADD_CUSTOM_TARGET(Name [ALL] [command1 [args1...]]
                           [COMMAND command2 [args2...] ...]
                           [DEPENDS depend depend depend ... ]
                           [WORKING_DIRECTORY dir]
                           [COMMENT comment] [VERBATIM])

       Adds a target with the given name that executes the given commands.
       The target has no output file and is ALWAYS CONSIDERED OUT OF DATE
       even if the commands try to create a file with the name of the target.
       Use ADD_CUSTOM_COMMAND to generate a file with dependencies.  By
       default nothing depends on the custom target.  Use ADD_DEPENDENCIES to
       add dependencies to or from other targets.  If the ALL option is
       specified it indicates that this target should be added to the default
       build target so that it will be run every time (the command cannot be
       called ALL).  The command and arguments are optional and if not
       specified an empty target will be created.  If WORKING_DIRECTORY is
       set, then the command will be run in that directory.  If COMMENT is
       set, the value will be displayed as a message before the commands are
       executed at build time.  Dependencies listed with the DEPENDS argument
       may reference files and outputs of custom commands created with
       ADD_CUSTOM_COMMAND.

       If VERBATIM is given then all the arguments to the commands will be
       passed exactly as specified no matter the build tool used.  Note that
       one level of escapes is still used by the CMake language processor
       before ADD_CUSTOM_TARGET even sees the arguments.  Use of VERBATIM is
       recommended as it enables correct behavior.  When VERBATIM is not
       given the behavior is platform specific.  In the future VERBATIM may
       be enabled by default.  The only reason it is an option is to preserve
       compatibility with older CMake code.

  ADD_DEFINITIONS
       Adds -D define flags to the command line of C and C++ compilers.

         ADD_DEFINITIONS(-DFOO -DBAR ...)

       Adds flags to command line of C and C++ compilers.  This command can
       be used to add any flag to a compile line, but the -D flag is accepted
       most C/C++ compilers.  Other flags may not be as portable.

  ADD_DEPENDENCIES
       Add a dependency between top-level targets.

         ADD_DEPENDENCIES(target-name depend-target1
                          depend-target2 ...)

       Make a top-level target depend on other top-level targets.  A
       top-level target is one created by ADD_EXECUTABLE, ADD_LIBRARY, or
       ADD_CUSTOM_TARGET.  Adding dependencies with this command can be used
       to make sure one target is built before another target.  See the
       DEPENDS option of ADD_CUSTOM_TARGET and ADD_CUSTOM_COMMAND for adding
       file-level dependencies in custom rules.  See the OBJECT_DEPENDS
       option in SET_SOURCE_FILES_PROPERTIES to add file-level dependencies
       to object files.

  ADD_EXECUTABLE
       Add an executable to the project using the specified source files.

         ADD_EXECUTABLE(exename [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL]
                        source1 source2 ... sourceN)

       This command adds an executable target to the current directory.  The
       executable will be built from the list of source files specified.

       After specifying the executable name, WIN32 and/or MACOSX_BUNDLE can
       be specified.  WIN32 indicates that the executable (when compiled on
       windows) is a windows app (using WinMain) not a console app (using
       main).  The variable CMAKE_MFC_FLAG be used if the windows app uses
       MFC.  This variable can be set to the following values:

        0: Use Standard Windows Libraries
        1: Use MFC in a Static Library 
        2: Use MFC in a Shared DLL 

       MACOSX_BUNDLE indicates that when build on Mac OSX, executable should
       be in the bundle form.  The MACOSX_BUNDLE also allows several
       variables to be specified:

         MACOSX_BUNDLE_INFO_STRING
         MACOSX_BUNDLE_ICON_FILE
         MACOSX_BUNDLE_GUI_IDENTIFIER
         MACOSX_BUNDLE_LONG_VERSION_STRING
         MACOSX_BUNDLE_BUNDLE_NAME
         MACOSX_BUNDLE_SHORT_VERSION_STRING
         MACOSX_BUNDLE_BUNDLE_VERSION
         MACOSX_BUNDLE_COPYRIGHT

       If EXCLUDE_FROM_ALL is given the target will not be built by default.
       It will be built only if the user explicitly builds the target or
       another target that requires the target depends on it.

  ADD_LIBRARY
       Add a library to the project using the specified source files.

         ADD_LIBRARY(libname [SHARED | STATIC | MODULE] [EXCLUDE_FROM_ALL]
                     source1 source2 ... sourceN)

       Adds a library target.  SHARED, STATIC or MODULE keywords are used to
       set the library type.  If the keyword MODULE appears, the library type
       is set to MH_BUNDLE on systems which use dyld.  On systems without
       dyld, MODULE is treated like SHARED.  If no keywords appear as the
       second argument, the type defaults to the current value of
       BUILD_SHARED_LIBS.  If this variable is not set, the type defaults to
       STATIC.

       If EXCLUDE_FROM_ALL is given the target will not be built by default.
       It will be built only if the user explicitly builds the target or
       another target that requires the target depends on it.

  ADD_SUBDIRECTORY
       Add a subdirectory to the build.

         ADD_SUBDIRECTORY(source_dir [binary_dir] 
                          [EXCLUDE_FROM_ALL])

       Add a subdirectory to the build.  The source_dir specifies the
       directory in which the source CmakeLists.txt and code files are
       located.  If it is a relative path it will be evaluated with respect
       to the current directory (the typical usage), but it may also be an
       absolute path.  The binary_dir specifies the directory in which to
       place the output files.  If it is a relative path it will be evaluated
       with respect to the current output directory, but it may also be an
       absolute path.  If binary_dir is not specified, the value of
       source_dir, before expanding any relative path, will be used (the
       typical usage).  The CMakeLists.txt file in the specified source
       directory will be processed immediately by CMake before processing in
       the current input file continues beyond this command.

       If the EXCLUDE_FROM_ALL argument is provided then this subdirectory
       will not be included in build by default.  Users will have to
       explicitly start a build in the generated output directory.  This is
       useful for having cmake create a build system for a set of examples in
       a project.  One would want cmake to generate a single build system for
       all the examples, but one may not want the targets to show up in the
       main build system.

  ADD_TEST
       Add a test to the project with the specified arguments.

         ADD_TEST(testname Exename arg1 arg2 ...)

       If the ENABLE_TESTING command has been run, this command adds a test
       target to the current directory.  If ENABLE_TESTING has not been run,
       this command does nothing.  The tests are run by the testing subsystem
       by executing Exename with the specified arguments.  Exename can be
       either an executable built by this project or an arbitrary executable
       on the system (like tclsh).  The test will be run with the current
       working directory set to the CMakeList.txt files corresponding
       directory in the binary tree.

  AUX_SOURCE_DIRECTORY
       Find all source files in a directory.

         AUX_SOURCE_DIRECTORY(dir VARIABLE)

       Collects the names of all the source files in the specified directory
       and stores the list in the variable provided.  This command is
       intended to be used by projects that use explicit template
       instantiation.  Template instantiation files can be stored in a
       "Templates" subdirectory and collected automatically using this
       command to avoid manually listing all instantiations.

       It is tempting to use this command to avoid writing the list of source
       files for a library or executable target.  While this seems to work,
       there is no way for CMake to generate a build system that knows when a
       new source file has been added.  Normally the generated build system
       knows when it needs to rerun CMake because the CMakeLists.txt file is
       modified to add a new source.  When the source is just added to the
       directory without modifying this file, one would have to manually
       rerun CMake to generate a build system incorporating the new file.

  BUILD_COMMAND
       Get the command line that will build this project.

         BUILD_COMMAND(variable MAKECOMMAND)

       Sets the given variable to a string containing the command that will
       build this project from the root of the build tree using the build
       tool given by MAKECOMMAND.  MAKECOMMAND should be msdev, nmake, make
       or one of the end user build tools.  This is useful for configuring
       testing systems.

  BUILD_NAME
       Deprecated.  Use ${CMAKE_SYSTEM} and ${CMAKE_CXX_COMPILER} instead.

         BUILD_NAME(variable)

       Sets the specified variable to a string representing the platform and
       compiler settings.  These values are now available through the
       CMAKE_SYSTEM and CMAKE_CXX_COMPILER variables.

  CMAKE_MINIMUM_REQUIRED
       Set the minimum required version of cmake for a project.

         CMAKE_MINIMUM_REQUIRED(VERSION versionNumber [FATAL_ERROR])

       Let cmake know that the project requires a certain version of a cmake,
       or newer.  CMake will also try to be backwards compatible to the
       version of cmake specified, if a newer version of cmake is running.
       If FATAL_ERROR is given then failure to meet the requirements will be
       considered an error instead of a warning.

  CONFIGURE_FILE
       Copy a file to another location and modify its contents.

         CONFIGURE_FILE(InputFile OutputFile
                        [COPYONLY] [ESCAPE_QUOTES] [@ONLY])

       The Input and Ouput files have to have full paths.  This command
       replaces any variables in the input file referenced as ${VAR} or @VAR@
       with their values as determined by CMake.  If a variable is not
       defined, it will be replaced with nothing.  If COPYONLY is specified,
       then no variable expansion will take place.  If ESCAPE_QUOTES is
       specified then any substituted quotes will be C-style escaped.  The
       file will be configured with the current values of CMake variables.
       If @ONLY is specified, only variables of the form @VAR@ will be
       replaces and ${VAR} will be ignored.  This is useful for configuring
       scripts that use ${VAR}.  Any occurrences of #cmakedefine VAR will be
       replaced with either #define VAR or /* #undef VAR */ depending on the
       setting of VAR in CMake

  CREATE_TEST_SOURCELIST
       Create a test driver and source list for building test programs.

         CREATE_TEST_SOURCELIST(SourceListName DriverName
                                test1 test2 test3
                                EXTRA_INCLUDE include.h
                                FUNCTION function)

       A test driver is a program that links together many small tests into a
       single executable.  This is useful when building static executables
       with large libraries to shrink the total required size.  The list of
       source files needed to build the test driver will be in
       SourceListName.  DriverName is the name of the test driver program.
       The rest of the arguments consist of a list of test source files, can
       be semicolon separated.  Each test source file should have a function
       in it that is the same name as the file with no extension (foo.cxx
       should have int foo();) DriverName will be able to call each of the
       tests by name on the command line.  If EXTRA_INCLUDE is specified,
       then the next argument is included into the generated file.  If
       FUNCTION is specified, then the next argument is taken as a function
       name that is passed a pointer to ac and av.  This can be used to add
       extra command line processing to each test.  The cmake variable
       CMAKE_TESTDRIVER_BEFORE_TESTMAIN can be set to have code that will be
       placed directly before calling the test main function.
       CMAKE_TESTDRIVER_AFTER_TESTMAIN can be set to have code that will be
       placed directly after the call to the test main function.

  ELSE
       Starts the ELSE portion of an IF block.

         ELSE(expression)

       See the IF command.

  ELSEIF
       Starts the ELSEIF portion of an IF block.

         ELSEIF(expression)

       See the IF command.

  ENABLE_LANGUAGE
       Set a name for the entire project.

         ENABLE_LANGUAGE(languageName)

       This command enables support for the named language in CMake.

  ENABLE_TESTING
       Enable testing for current directory and below.

         ENABLE_TESTING()

       Enables testing for this directory and below.  See also the ADD_TEST
       command.  Note that ctest expects to find a test file in the build
       directory root.  Therefore, this command should be in the source
       directory root.

  ENDFOREACH
       Ends a list of commands in a FOREACH block.

         ENDFOREACH(expression)

       See the FOREACH command.

  ENDIF
       Ends a list of commands in an IF block.

         ENDIF(expression)

       See the IF command.

  ENDMACRO
       Ends a list of commands in a MACRO block.

         ENDMACRO(expression)

       See the MACRO command.

  ENDWHILE
       Ends a list of commands in a WHILE block.

         ENDWHILE(expression)

       See the WHILE command.

  EXEC_PROGRAM
       Run and executable program during the processing of the CMakeList.txt
       file.

         EXEC_PROGRAM(Executable [directory in which to run]
                      [ARGS <arguments to executable>]
                      [OUTPUT_VARIABLE <var>]
                      [RETURN_VALUE <var>])

       The executable is run in the optionally specified directory.  The
       executable can include arguments if it is double quoted, but it is
       better to use the optional ARGS argument to specify arguments to the
       program.  This is because cmake will then be able to escape spaces in
       the executable path.  An optional argument OUTPUT_VARIABLE specifies a
       variable in which to store the output.  To capture the return value of
       the execution, provide a RETURN_VALUE.  If OUTPUT_VARIABLE is
       specified, then no output will go to the stdout/stderr of the console
       running cmake.

       The EXECUTE_PROCESS command is a newer more powerful version of
       EXEC_PROGRAM, but the old command has been kept for compatibility.

  EXECUTE_PROCESS
       Execute one or more child processes.

         EXECUTE_PROCESS(COMMAND <cmd1> [args1...]]
                         [COMMAND <cmd2> [args2...] [...]]
                         [WORKING_DIRECTORY <directory>]
                         [TIMEOUT <seconds>]
                         [RESULT_VARIABLE <variable>]
                         [OUTPUT_VARIABLE <variable>]
                         [ERROR_VARIABLE <variable>]
                         [INPUT_FILE <file>]
                         [OUTPUT_FILE <file>]
                         [ERROR_FILE <file>]
                         [OUTPUT_QUIET]
                         [ERROR_QUIET]
                         [OUTPUT_STRIP_TRAILING_WHITESPACE]
                         [ERROR_STRIP_TRAILING_WHITESPACE])

       Runs the given sequence of one or more commands with the standard
       output of each process piped to the standard input of the next.  A
       single standard error pipe is used for all processes.  If
       WORKING_DIRECTORY is given the named directory will be set as the
       current working directory of the child processes.  If TIMEOUT is given
       the child processes will be terminated if they do not finish in the
       specified number of seconds (fractions are allowed).  If
       RESULT_VARIABLE is given the variable will be set to contain the
       result of running the processes.  This will be an integer return code
       from the last child or a string describing an error condition.  If
       OUTPUT_VARIABLE or ERROR_VARIABLE are given the variable named will be
       set with the contents of the standard output and standard error pipes
       respectively.  If the same variable is named for both pipes their
       output will be merged in the order produced.  If INPUT_FILE,
       OUTPUT_FILE, or ERROR_FILE is given the file named will be attached to
       the standard input of the first process, standard output of the last
       process, or standard error of all processes respectively.  If
       OUTPUT_QUIET or ERROR_QUIET is given then the standard output or
       standard error results will be quietly ignored.  If more than one
       OUTPUT_* or ERROR_* option is given for the same pipe the precedence
       is not specified.  If no OUTPUT_* or ERROR_* options are given the
       output will be shared with the corresponding pipes of the CMake
       process itself.

       The EXECUTE_PROCESS command is a newer more powerful version of
       EXEC_PROGRAM, but the old command has been kept for compatibility.

  EXPORT_LIBRARY_DEPENDENCIES
       Write out the dependency information for all targets of a project.

         EXPORT_LIBRARY_DEPENDENCIES(FILE [APPEND])

       Create a file that can be included into a CMake listfile with the
       INCLUDE command.  The file will contain a number of SET commands that
       will set all the variables needed for library dependency information.
       This should be the last command in the top level CMakeLists.txt file
       of the project.  If the APPEND option is specified, the SET commands
       will be appended to the given file instead of replacing it.

  FILE
       File manipulation command.

         FILE(WRITE filename "message to write"... )
         FILE(APPEND filename "message to write"... )
         FILE(READ filename variable)
         FILE(GLOB variable [RELATIVE path] [globbing expressions]...)
         FILE(GLOB_RECURSE variable [RELATIVE path] 
              [globbing expressions]...)
         FILE(REMOVE [directory]...)
         FILE(REMOVE_RECURSE [directory]...)
         FILE(MAKE_DIRECTORY [directory]...)
         FILE(RELATIVE_PATH variable directory file)
         FILE(TO_CMAKE_PATH path result)
         FILE(TO_NATIVE_PATH path result)

       WRITE will write a message into a file called 'filename'.  It
       overwrites the file if it already exists, and creates the file if it
       does not exist.

       APPEND will write a message into a file same as WRITE, except it will
       append it to the end of the file

       NOTE: When using FILE WRITE and FILE APPEND, the produced file cannot
       be used as an input to CMake (CONFIGURE_FILE, source file ...) because
       it will lead to an infinite loop.  Use CONFIGURE_FILE if you want to
       generate input files to CMake.

       READ will read the content of a file and store it into the variable.

       GLOB will generate a list of all files that match the globbing
       expressions and store it into the variable.  Globbing expressions are
       similar to regular expressions, but much simpler.  If RELATIVE flag is
       specified for an expression, the results will be returned as a
       relative path to the given path.

       Examples of globbing expressions include:

          *.cxx      - match all files with extension cxx
          *.vt?      - match all files with extension vta,...,vtz
          f[3-5].txt - match files f3.txt, f4.txt, f5.txt

       GLOB_RECURSE will generate similar list as the regular GLOB, except it
       will traverse all the subdirectories of the matched directory and
       match the files.

       Examples of recursive globbing include:

          /dir/*.py  - match all python files in /dir and subdirectories

       MAKE_DIRECTORY will create a directory at the specified location

       RELATIVE_PATH will determine relative path from directory to the given
       file.

       TO_CMAKE_PATH will convert path into a cmake sytle path with unix /.
       The input can be a single path or a system path like "$ENV{PATH}".
       Note the double quotes around the ENV call TO_CMAKE_PATH only takes
       one argument.

       TO_NATIVE_PATH works just like TO_CMAKE_PATH, but will convert from a
       cmake style path into the native path style \ for windows and / for
       UNIX.

  FIND_FILE
       Find the full path to a file.

          FIND_FILE(<VAR> name1 path1 path2 ...)

       This is the short-hand signature for the command that is sufficient in
       many cases.  It is the same as FIND_FILE(<VAR> name1 PATHS path2 path2
       ...)

          FIND_FILE(
                    <VAR> 
                    name | NAMES name1 [name2 ...]
                    PATHS path1 [path2 ... ENV var]
                    [PATH_SUFFIXES suffix1 [suffix2 ...]]
                    [DOC "cache documentation string"]
                    [NO_DEFAULT_PATH]
                    [NO_CMAKE_ENVIRONMENT_PATH]
                    [NO_CMAKE_PATH]
                    [NO_SYSTEM_ENVIRONMENT_PATH]
                    [NO_CMAKE_SYSTEM_PATH]
                   )

       This command is used to find a full path to named file.  A cache entry
       named by <VAR> is created to store the result of this command.  If the
       full path to a file is found the result is stored in the variable and
       the search will not be repeated unless the variable is cleared.  If
       nothing is found, the result will be <VAR>-NOTFOUND, and the search
       will be attempted again the next time FIND_FILE is invoked with the
       same variable.  The name of the full path to a file that is searched
       for is specified by the names listed after the NAMES argument.
       Additional search locations can be specified after the PATHS argument.
       If ENV var is found in the PATHS section the environment variable var
       will be read and converted from a system environment variable to a
       cmake style list of paths.  For example ENV PATH would be a way to
       list the system path variable.  The argument after DOC will be used
       for the documentation string in the cache.  PATH_SUFFIXES can be used
       to give sub directories that will be appended to the search paths.

       If NO_DEFAULT_PATH is specified, then no additional paths are added to
       the search.  If NO_DEFAULT_PATH is not specified, the search process
       is as follows:

       1.  Search cmake specific environment variables.  This can be skipped
       if NO_CMAKE_ENVIRONMENT_PATH is passed.

          CMAKE_FRAMEWORK_PATH
          CMAKE_APPBUNDLE_PATH
          CMAKE_INCLUDE_PATH

       2.  Search cmake variables with the same names as the cmake specific
       environment variables.  These are intended to be used on the command
       line with a -DVAR=value.  This can be skipped if NO_CMAKE_PATH is
       passed.

          CMAKE_FRAMEWORK_PATH
          CMAKE_APPBUNDLE_PATH
          CMAKE_INCLUDE_PATH

       3.  Search the standard system environment variables.  This can be
       skipped if NO_SYSTEM_ENVIRONMENT_PATH is an argument.

          PATH
          INCLUDE

       4.  Search cmake variables defined in the Platform files for the
       current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is
       passed.

          CMAKE_SYSTEM_FRAMEWORK_PATH
          CMAKE_SYSTEM_APPBUNDLE_PATH
          CMAKE_SYSTEM_INCLUDE_PATH

       5.  Search the paths specified after PATHS or in the short-hand
       version of the command.

       On Darwin or systems supporting OSX Frameworks, the cmake variable
       CMAKE_FIND_FRAMEWORK can be set to empty or one of the following:

          "FIRST"  - Try to find frameworks before standard
                     libraries or headers. This is the default on Darwin.
          "LAST"   - Try to find frameworks after standard
                     libraries or headers.
          "ONLY"   - Only try to find frameworks.
          "NEVER". - Never try to find frameworks.

       On Darwin or systems supporting OSX Application Bundles, the cmake
       variable CMAKE_FIND_APPBUNDLE can be set to empty or one of the
       following:

          "FIRST"  - Try to find application bundles before standard
                     programs. This is the default on Darwin.
          "LAST"   - Try to find application bundles after standard
                     programs.
          "ONLY"   - Only try to find application bundles.
          "NEVER". - Never try to find application bundles.

       The reason the paths listed in the call to the command are searched
       last is that most users of CMake would expect things to be found first
       in the locations specified by their environment.  Projects may
       override this behavior by simply calling the command twice:

          FIND_FILE(<VAR> NAMES name PATHS paths NO_DEFAULT_PATH)
          FIND_FILE(<VAR> NAMES name)

       Once one of these calls succeeds the result variable will be set and
       stored in the cache so that neither call will search again.

  FIND_LIBRARY
       Find a library.

          FIND_LIBRARY(<VAR> name1 path1 path2 ...)

       This is the short-hand signature for the command that is sufficient in
       many cases.  It is the same as FIND_LIBRARY(<VAR> name1 PATHS path2
       path2 ...)

          FIND_LIBRARY(
                    <VAR> 
                    name | NAMES name1 [name2 ...]
                    PATHS path1 [path2 ... ENV var]
                    [PATH_SUFFIXES suffix1 [suffix2 ...]]
                    [DOC "cache documentation string"]
                    [NO_DEFAULT_PATH]
                    [NO_CMAKE_ENVIRONMENT_PATH]
                    [NO_CMAKE_PATH]
                    [NO_SYSTEM_ENVIRONMENT_PATH]
                    [NO_CMAKE_SYSTEM_PATH]
                   )

       This command is used to find a library.  A cache entry named by <VAR>
       is created to store the result of this command.  If the library is
       found the result is stored in the variable and the search will not be
       repeated unless the variable is cleared.  If nothing is found, the
       result will be <VAR>-NOTFOUND, and the search will be attempted again
       the next time FIND_LIBRARY is invoked with the same variable.  The
       name of the library that is searched for is specified by the names
       listed after the NAMES argument.  Additional search locations can be
       specified after the PATHS argument.  If ENV var is found in the PATHS
       section the environment variable var will be read and converted from a
       system environment variable to a cmake style list of paths.  For
       example ENV PATH would be a way to list the system path variable.  The
       argument after DOC will be used for the documentation string in the
       cache.  PATH_SUFFIXES can be used to give sub directories that will be
       appended to the search paths.

       If NO_DEFAULT_PATH is specified, then no additional paths are added to
       the search.  If NO_DEFAULT_PATH is not specified, the search process
       is as follows:

       1.  Search cmake specific environment variables.  This can be skipped
       if NO_CMAKE_ENVIRONMENT_PATH is passed.

          CMAKE_FRAMEWORK_PATH
          CMAKE_APPBUNDLE_PATH
          CMAKE_LIBRARY_PATH

       2.  Search cmake variables with the same names as the cmake specific
       environment variables.  These are intended to be used on the command
       line with a -DVAR=value.  This can be skipped if NO_CMAKE_PATH is
       passed.

          CMAKE_FRAMEWORK_PATH
          CMAKE_APPBUNDLE_PATH
          CMAKE_LIBRARY_PATH

       3.  Search the standard system environment variables.  This can be
       skipped if NO_SYSTEM_ENVIRONMENT_PATH is an argument.

          PATH
          LIB

       4.  Search cmake variables defined in the Platform files for the
       current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is
       passed.

          CMAKE_SYSTEM_FRAMEWORK_PATH
          CMAKE_SYSTEM_APPBUNDLE_PATH
          CMAKE_SYSTEM_LIBRARY_PATH

       5.  Search the paths specified after PATHS or in the short-hand
       version of the command.

       On Darwin or systems supporting OSX Frameworks, the cmake variable
       CMAKE_FIND_FRAMEWORK can be set to empty or one of the following:

          "FIRST"  - Try to find frameworks before standard
                     libraries or headers. This is the default on Darwin.
          "LAST"   - Try to find frameworks after standard
                     libraries or headers.
          "ONLY"   - Only try to find frameworks.
          "NEVER". - Never try to find frameworks.

       On Darwin or systems supporting OSX Application Bundles, the cmake
       variable CMAKE_FIND_APPBUNDLE can be set to empty or one of the
       following:

          "FIRST"  - Try to find application bundles before standard
                     programs. This is the default on Darwin.
          "LAST"   - Try to find application bundles after standard
                     programs.
          "ONLY"   - Only try to find application bundles.
          "NEVER". - Never try to find application bundles.

       The reason the paths listed in the call to the command are searched
       last is that most users of CMake would expect things to be found first
       in the locations specified by their environment.  Projects may
       override this behavior by simply calling the command twice:

          FIND_LIBRARY(<VAR> NAMES name PATHS paths NO_DEFAULT_PATH)
          FIND_LIBRARY(<VAR> NAMES name)

       Once one of these calls succeeds the result variable will be set and
       stored in the cache so that neither call will search again.

       If the library found is a framework, then VAR will be set to the full
       path to the framework <fullPath>/A.framework.  When a full path to a
       framework is used as a library, CMake will use a -framework A, and a
       -F<fullPath> to link the framework to the target.

  FIND_PACKAGE
       Load settings for an external project.

         FIND_PACKAGE(<name> [major.minor] [QUIET] [NO_MODULE]
                      [[REQUIRED|COMPONENTS] [componets...]])

       Finds and loads settings from an external project.  <name>_FOUND will
       be set to indicate whether the package was found.  Settings that can
       be used when <name>_FOUND is true are package-specific.  The package
       is found through several steps.  Directories listed in
       CMAKE_MODULE_PATH are searched for files called "Find<name>.cmake".
       If such a file is found, it is read and processed by CMake, and is
       responsible for finding the package.  This first step may be skipped
       by using the NO_MODULE option.  If no such file is found, it is
       expected that the package is another project built by CMake that has a
       "<name>Config.cmake" file.  A cache entry called <name>_DIR is created
       and is expected to be set to the directory containing this file.  If
       the file is found, it is read and processed by CMake to load the
       settings of the package.  If <name>_DIR has not been set during a
       configure step, the command will generate an error describing the
       problem unless the QUIET argument is specified.  If <name>_DIR has
       been set to a directory not containing a "<name>Config.cmake" file, an
       error is always generated.  If REQUIRED is specified and the package
       is not found, a FATAL_ERROR is generated and the configure step stops
       executing.  A package-specific list of components may be listed after
       the REQUIRED option, or after the COMPONENTS option if no REQUIRED
       option is given.

  FIND_PATH
       Find the directory containing a file.

          FIND_PATH(<VAR> name1 path1 path2 ...)

       This is the short-hand signature for the command that is sufficient in
       many cases.  It is the same as FIND_PATH(<VAR> name1 PATHS path2 path2
       ...)

          FIND_PATH(
                    <VAR> 
                    name | NAMES name1 [name2 ...]
                    PATHS path1 [path2 ... ENV var]
                    [PATH_SUFFIXES suffix1 [suffix2 ...]]
                    [DOC "cache documentation string"]
                    [NO_DEFAULT_PATH]
                    [NO_CMAKE_ENVIRONMENT_PATH]
                    [NO_CMAKE_PATH]
                    [NO_SYSTEM_ENVIRONMENT_PATH]
                    [NO_CMAKE_SYSTEM_PATH]
                   )

       This command is used to find a directory containing the named file.  A
       cache entry named by <VAR> is created to store the result of this
       command.  If the file in a directory is found the result is stored in
       the variable and the search will not be repeated unless the variable
       is cleared.  If nothing is found, the result will be <VAR>-NOTFOUND,
       and the search will be attempted again the next time FIND_PATH is
       invoked with the same variable.  The name of the file in a directory
       that is searched for is specified by the names listed after the NAMES
       argument.  Additional search locations can be specified after the
       PATHS argument.  If ENV var is found in the PATHS section the
       environment variable var will be read and converted from a system
       environment variable to a cmake style list of paths.  For example ENV
       PATH would be a way to list the system path variable.  The argument
       after DOC will be used for the documentation string in the cache.
       PATH_SUFFIXES can be used to give sub directories that will be
       appended to the search paths.

       If NO_DEFAULT_PATH is specified, then no additional paths are added to
       the search.  If NO_DEFAULT_PATH is not specified, the search process
       is as follows:

       1.  Search cmake specific environment variables.  This can be skipped
       if NO_CMAKE_ENVIRONMENT_PATH is passed.

          CMAKE_FRAMEWORK_PATH
          CMAKE_APPBUNDLE_PATH
          CMAKE_INCLUDE_PATH

       2.  Search cmake variables with the same names as the cmake specific
       environment variables.  These are intended to be used on the command
       line with a -DVAR=value.  This can be skipped if NO_CMAKE_PATH is
       passed.

          CMAKE_FRAMEWORK_PATH
          CMAKE_APPBUNDLE_PATH
          CMAKE_INCLUDE_PATH

       3.  Search the standard system environment variables.  This can be
       skipped if NO_SYSTEM_ENVIRONMENT_PATH is an argument.

          PATH
          INCLUDE

       4.  Search cmake variables defined in the Platform files for the
       current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is
       passed.

          CMAKE_SYSTEM_FRAMEWORK_PATH
          CMAKE_SYSTEM_APPBUNDLE_PATH
          CMAKE_SYSTEM_INCLUDE_PATH

       5.  Search the paths specified after PATHS or in the short-hand
       version of the command.

       On Darwin or systems supporting OSX Frameworks, the cmake variable
       CMAKE_FIND_FRAMEWORK can be set to empty or one of the following:

          "FIRST"  - Try to find frameworks before standard
                     libraries or headers. This is the default on Darwin.
          "LAST"   - Try to find frameworks after standard
                     libraries or headers.
          "ONLY"   - Only try to find frameworks.
          "NEVER". - Never try to find frameworks.

       On Darwin or systems supporting OSX Application Bundles, the cmake
       variable CMAKE_FIND_APPBUNDLE can be set to empty or one of the
       following:

          "FIRST"  - Try to find application bundles before standard
                     programs. This is the default on Darwin.
          "LAST"   - Try to find application bundles after standard
                     programs.
          "ONLY"   - Only try to find application bundles.
          "NEVER". - Never try to find application bundles.

       The reason the paths listed in the call to the command are searched
       last is that most users of CMake would expect things to be found first
       in the locations specified by their environment.  Projects may
       override this behavior by simply calling the command twice:

          FIND_PATH(<VAR> NAMES name PATHS paths NO_DEFAULT_PATH)
          FIND_PATH(<VAR> NAMES name)

       Once one of these calls succeeds the result variable will be set and
       stored in the cache so that neither call will search again.

       When searching for frameworks, if the file is specified as A/b.h, then
       the framework search will look for A.framework/Headers/b.h.  If that
       is found the path will be set to the path to the framework.  CMake
       will convert this to the correct -F option to include the file.

  FIND_PROGRAM
       Find an executable program.

          FIND_PROGRAM(<VAR> name1 path1 path2 ...)

       This is the short-hand signature for the command that is sufficient in
       many cases.  It is the same as FIND_PROGRAM(<VAR> name1 PATHS path2
       path2 ...)

          FIND_PROGRAM(
                    <VAR> 
                    name | NAMES name1 [name2 ...]
                    PATHS path1 [path2 ... ENV var]
                    [PATH_SUFFIXES suffix1 [suffix2 ...]]
                    [DOC "cache documentation string"]
                    [NO_DEFAULT_PATH]
                    [NO_CMAKE_ENVIRONMENT_PATH]
                    [NO_CMAKE_PATH]
                    [NO_SYSTEM_ENVIRONMENT_PATH]
                    [NO_CMAKE_SYSTEM_PATH]
                   )

       This command is used to find a program.  A cache entry named by <VAR>
       is created to store the result of this command.  If the program is
       found the result is stored in the variable and the search will not be
       repeated unless the variable is cleared.  If nothing is found, the
       result will be <VAR>-NOTFOUND, and the search will be attempted again
       the next time FIND_PROGRAM is invoked with the same variable.  The
       name of the program that is searched for is specified by the names
       listed after the NAMES argument.  Additional search locations can be
       specified after the PATHS argument.  If ENV var is found in the PATHS
       section the environment variable var will be read and converted from a
       system environment variable to a cmake style list of paths.  For
       example ENV PATH would be a way to list the system path variable.  The
       argument after DOC will be used for the documentation string in the
       cache.  PATH_SUFFIXES can be used to give sub directories that will be
       appended to the search paths.

       If NO_DEFAULT_PATH is specified, then no additional paths are added to
       the search.  If NO_DEFAULT_PATH is not specified, the search process
       is as follows:

       1.  Search cmake specific environment variables.  This can be skipped
       if NO_CMAKE_ENVIRONMENT_PATH is passed.

          CMAKE_FRAMEWORK_PATH
          CMAKE_APPBUNDLE_PATH
          CMAKE_PROGRAM_PATH

       2.  Search cmake variables with the same names as the cmake specific
       environment variables.  These are intended to be used on the command
       line with a -DVAR=value.  This can be skipped if NO_CMAKE_PATH is
       passed.

          CMAKE_FRAMEWORK_PATH
          CMAKE_APPBUNDLE_PATH
          CMAKE_PROGRAM_PATH

       3.  Search the standard system environment variables.  This can be
       skipped if NO_SYSTEM_ENVIRONMENT_PATH is an argument.

          PATH
          

       4.  Search cmake variables defined in the Platform files for the
       current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is
       passed.

          CMAKE_SYSTEM_FRAMEWORK_PATH
          CMAKE_SYSTEM_APPBUNDLE_PATH
          CMAKE_SYSTEM_PROGRAM_PATH

       5.  Search the paths specified after PATHS or in the short-hand
       version of the command.

       On Darwin or systems supporting OSX Frameworks, the cmake variable
       CMAKE_FIND_FRAMEWORK can be set to empty or one of the following:

          "FIRST"  - Try to find frameworks before standard
                     libraries or headers. This is the default on Darwin.
          "LAST"   - Try to find frameworks after standard
                     libraries or headers.
          "ONLY"   - Only try to find frameworks.
          "NEVER". - Never try to find frameworks.

       On Darwin or systems supporting OSX Application Bundles, the cmake
       variable CMAKE_FIND_APPBUNDLE can be set to empty or one of the
       following:

          "FIRST"  - Try to find application bundles before standard
                     programs. This is the default on Darwin.
          "LAST"   - Try to find application bundles after standard
                     programs.
          "ONLY"   - Only try to find application bundles.
          "NEVER". - Never try to find application bundles.

       The reason the paths listed in the call to the command are searched
       last is that most users of CMake would expect things to be found first
       in the locations specified by their environment.  Projects may
       override this behavior by simply calling the command twice:

          FIND_PROGRAM(<VAR> NAMES name PATHS paths NO_DEFAULT_PATH)
          FIND_PROGRAM(<VAR> NAMES name)

       Once one of these calls succeeds the result variable will be set and
       stored in the cache so that neither call will search again.

  FLTK_WRAP_UI
       Create FLTK user interfaces Wrappers.

         FLTK_WRAP_UI(resultingLibraryName source1
                      source2 ... sourceN )

       Produce .h and .cxx files for all the .fl and .fld files listed.  The
       resulting .h and .cxx files will be added to a variable named
       resultingLibraryName_FLTK_UI_SRCS which should be added to your
       library.

  FOREACH
       Evaluate a group of commands for each value in a list.

         FOREACH(loop_var arg1 arg2 ...)
           COMMAND1(ARGS ...)
           COMMAND2(ARGS ...)
           ...
         ENDFOREACH(loop_var)
         FOREACH(loop_var RANGE total)
         FOREACH(loop_var RANGE start stop [step])

       All commands between FOREACH and the matching ENDFOREACH are recorded
       without being invoked.  Once the ENDFOREACH is evaluated, the recorded
       list of commands is invoked once for each argument listed in the
       original FOREACH command.  Before each iteration of the loop
       "${loop_var}" will be set as a variable with the current value in the
       list.

       Foreach can also iterate over a generated range of numbers.  There are
       three types of this iteration:

       * When specifying single number, the range will have elements 0 to
       "total".

       * When specifying two numbers, the range will have elements from the
       first number to the second number.

       * The third optional number is the increment used to iterate from the
       first number to the second number.

  GET_CMAKE_PROPERTY
       Get a property of the CMake instance.

         GET_CMAKE_PROPERTY(VAR property)

       Get a property from the CMake instance.  The value of the property is
       stored in the variable VAR.  If the property is not found, CMake will
       report an error.  Some supported properties include: VARIABLES,
       CACHE_VARIABLES, COMMANDS, and MACROS.

  GET_DIRECTORY_PROPERTY
       Get a property of the directory.

         GET_DIRECTORY_PROPERTY(VAR [DIRECTORY dir] property)

       Get a property from the Directory.  The value of the property is
       stored in the variable VAR.  If the property is not found, CMake will
       report an error.  The properties include: VARIABLES, CACHE_VARIABLES,
       COMMANDS, MACROS, INCLUDE_DIRECTORIES, LINK_DIRECTORIES, DEFINITIONS,
       INCLUDE_REGULAR_EXPRESSION, LISTFILE_STACK, PARENT_DIRECTORY, and
       DEFINITION varname.  If the DIRECTORY argument is provided then the
       property of the provided directory will be retrieved instead of the
       current directory.  You can only get properties of a directory during
       or after it has been traversed by cmake.

  GET_FILENAME_COMPONENT
       Get a specific component of a full filename.

         GET_FILENAME_COMPONENT(VarName FileName
                                PATH|ABSOLUTE|NAME|EXT|NAME_WE
                                [CACHE])

       Set VarName to be the path (PATH), file name (NAME), file extension
       (EXT), file name without extension (NAME_WE) of FileName, or the full
       absolute (ABSOLUTE) file name without symlinks.  Note that the path is
       converted to Unix slashes format and has no trailing slashes.  The
       longest file extension is always considered.  If the optional CACHE
       argument is specified, the result variable is added to the cache.

         GET_FILENAME_COMPONENT(VarName FileName
                                PROGRAM [PROGRAM_ARGS ArgVar]
                                [CACHE])

       The program in FileName will be found in the system search path or
       left as a full path.  If PROGRAM_ARGS is present with PROGRAM, then
       any command-line arguments present in the FileName string are split
       from the program name and stored in ArgVar.  This is used to separate
       a program name from its arguments in a command line string.

  GET_SOURCE_FILE_PROPERTY
       Get a property for a source file.

         GET_SOURCE_FILE_PROPERTY(VAR file property)

       Get a property from a source file.  The value of the property is
       stored in the variable VAR.  If the property is not found, VAR will be
       set to "NOTFOUND".  Use SET_SOURCE_FILES_PROPERTIES to set property
       values.  Source file properties usually control how the file is built.
       One property that is always there is LOCATION

  GET_TARGET_PROPERTY
       Get a property from a target.

         GET_TARGET_PROPERTY(VAR target property)

       Get a property from a target.  The value of the property is stored in
       the variable VAR.  If the property is not found, VAR will be set to
       "NOTFOUND".  Use SET_TARGET_PROPERTIES to set property values.
       Properties are usually used to control how a target is built.

       The read-only property "<CONFIG>_LOCATION" provides the full path to
       the file on disk that will be created for the target when building
       under configuration <CONFIG> (in upper-case, such as
       "DEBUG_LOCATION").  The read-only property "LOCATION" specifies the
       full path to the file on disk that will be created for the target.
       The path may contain a build-system-specific portion that is replaced
       at build time with the configuration getting built (such as
       "$(ConfigurationName)" in VS).  This is very useful for executable
       targets to get the path to the executable file for use in a custom
       command.

       The read-only property "TYPE" returns which type the specified target
       has (EXECUTABLE, STATIC_LIBRARY, SHARED_LIBRARY, MODULE_LIBRARY,
       UTILITY, INSTALL_FILES or INSTALL_PROGRAMS).  This command can get
       properties for any target so far created.  The targets do not need to
       be in the current CMakeLists.txt file.

  GET_TEST_PROPERTY
       Get a property of the test.

         GET_TEST_PROPERTY(test VAR property)

       Get a property from the Test.  The value of the property is stored in
       the variable VAR.  If the property is not found, CMake will report an
       error.

  IF
       Conditionally execute a group of commands.

         IF(expression)
           # THEN section.
           COMMAND1(ARGS ...)
           COMMAND2(ARGS ...)
           ...
         ELSE(expression)
           # ELSE section.
           COMMAND1(ARGS ...)
           COMMAND2(ARGS ...)
           ...
         ENDIF(expression)

       Evaluates the given expression.  If the result is true, the commands
       in the THEN section are invoked.  Otherwise, the commands in the ELSE
       section are invoked.  The ELSE section is optional.  Note that the
       same expression must be given to IF, ELSE, and ENDIF.  Long
       expressions can be used and the order or precedence is that the
       EXISTS, COMMAND, and DEFINED operators will be evaluated first.  Then
       any EQUAL, LESS, GREATER, STRLESS, STRGREATER, STREQUAL, MATCHES will
       be evaluated.  Then NOT operators and finally AND, OR operators will
       be evaluated.  Possible expressions are:

         IF(variable)

       True if the variable's value is not empty, 0, N, NO, OFF, FALSE,
       NOTFOUND, or <variable>-NOTFOUND.

         IF(NOT variable)

       True if the variable's value is empty, 0, N, NO, OFF, FALSE, NOTFOUND,
       or <variable>-NOTFOUND.

         IF(variable1 AND variable2)

       True if both variables would be considered true individually.

         IF(variable1 OR variable2)

       True if either variable would be considered true individually.

         IF(COMMAND command-name)

       True if the given name is a command that can be invoked.

         IF(EXISTS file-name)
         IF(EXISTS directory-name)

       True if the named file or directory exists.  Behavior is well-defined
       only for full paths.

         IF(file1 IS_NEWER_THAN file2)

       True if file1 is newer than file2 or if one of the two files doesn't
       exist.  Behavior is well-defined only for full paths.

         IF(IS_DIRECTORY directory-name)

       True if the given name is a directory.  Behavior is well-defined only
       for full paths.

         IF(variable MATCHES regex)
         IF(string MATCHES regex)

       True if the given string or variable's value matches the given regular
       expression.

         IF(variable LESS number)
         IF(string LESS number)
         IF(variable GREATER number)
         IF(string GREATER number)
         IF(variable EQUAL number)
         IF(string EQUAL number)

       True if the given string or variable's value is a valid number and the
       inequality or equality is true.

         IF(variable STRLESS string)
         IF(string STRLESS string)
         IF(variable STRGREATER string)
         IF(string STRGREATER string)
         IF(variable STREQUAL string)
         IF(string STREQUAL string)

       True if the given string or variable's value is lexicographically less
       (or greater, or equal) than the string on the right.

         IF(DEFINED variable)

       True if the given variable is defined.  It does not matter if the
       variable is true or false just if it has been set.

  INCLUDE
       Read CMake listfile code from the given file.

         INCLUDE(file1 [OPTIONAL])
         INCLUDE(module [OPTIONAL])

       Reads CMake listfile code from the given file.  Commands in the file
       are processed immediately as if they were written in place of the
       INCLUDE command.  If OPTIONAL is present, then no error is raised if
       the file does not exist.

       If a module is specified instead of a file, the file with name
       <modulename>.cmake is searched in the CMAKE_MODULE_PATH.

  INCLUDE_DIRECTORIES
       Add include directories to the build.

         INCLUDE_DIRECTORIES([AFTER|BEFORE] [SYSTEM] dir1 dir2 ...)

       Add the given directories to those searched by the compiler for
       include files.  By default the directories are appended onto the
       current list of directories.  This default behavior can be changed by
       setting CMAKE_INCLUDE_DIRECTORIES_BEFORE to ON.  By using BEFORE or
       AFTER you can select between appending and prepending, independent
       from the default.  If the SYSTEM option is given the compiler will be
       told that the directories are meant as system include directories on
       some platforms.

  INCLUDE_EXTERNAL_MSPROJECT
       Include an external Microsoft project file in a workspace.

         INCLUDE_EXTERNAL_MSPROJECT(projectname location
                                    dep1 dep2 ...)

       Includes an external Microsoft project in the generated workspace
       file.  Currently does nothing on UNIX.

  INCLUDE_REGULAR_EXPRESSION
       Set the regular expression used for dependency checking.

         INCLUDE_REGULAR_EXPRESSION(regex_match [regex_complain])

       Set the regular expressions used in dependency checking.  Only files
       matching regex_match will be traced as dependencies.  Only files
       matching regex_complain will generate warnings if they cannot be found
       (standard header paths are not searched).  The defaults are:

         regex_match    = "^.*$" (match everything)
         regex_complain = "^$" (match empty string only)

  INSTALL
       Specify rules to run at install time.

       This command generates installation rules for a project.  Rules
       specified by calls to this command within a source directory are
       executed in order during installation.  The order across directories
       is not defined.

       There are multiple signatures for this command.  Some of them define
       installation properties for files and targets.  Properties common to
       multiple signatures are covered here but they are valid only for
       signatures that specify them.  DESTINATION arguments specify the
       directory on disk to which a file will be installed.  If a full path
       (with a leading slash or drive letter) is given it is used directly.
       If a relative path is given it is interpreted relative to the value of
       CMAKE_INSTALL_PREFIX.  PERMISSIONS arguments specify permissions for
       installed files.  Valid permissions are OWNER_READ, OWNER_WRITE,
       OWNER_EXECUTE, GROUP_READ, GROUP_WRITE, GROUP_EXECUTE, WORLD_READ,
       WORLD_WRITE, WORLD_EXECUTE, SETUID, and SETGID.  Permissions that do
       not make sense on certain platforms are ignored on those platforms.
       The CONFIGURATIONS argument specifies a list of build configurations
       for which the install rule applies (Debug, Release, etc.).  The
       COMPONENT argument specifies an installation component name with which
       the install rule is associated, such as "runtime" or "development".
       During component-specific installation only install rules associated
       with the given component name will be executed.  During a full
       installation all components are installed.  The RENAME argument
       specifies a name for an installed file that may be different from the
       original file.  Renaming is allowed only when a single file is
       installed by the command.  The OPTIONAL argument specifies that it is
       not an error if the file to be installed does not exist.

       The TARGETS signature:

         INSTALL(TARGETS targets...
                 [[ARCHIVE|LIBRARY|RUNTIME]
                                     [DESTINATION <dir>]
                                     [PERMISSIONS permissions...]
                                     [CONFIGURATIONS [Debug|Release|...]]
                                     [COMPONENT <component>]
                                     [OPTIONAL]
                                    ] [...])

       The TARGETS form specifies rules for installing targets from a
       project.  There are three kinds of target files that may be installed:
       archive, library, and runtime.  Executables are always treated as
       runtime targets.  Static libraries are always treated as archive
       targets.  Module libraries are always treated as library targets.  For
       non-DLL platforms shared libraries are treated as library targets.
       For DLL platforms the DLL part of a shared library is treated as a
       runtime target and the corresponding import library is treated as an
       archive target.  All Windows-based systems including Cygwin are DLL
       platforms.  The ARCHIVE, LIBRARY, and RUNTIME arguments change the
       type of target to which the subsequent properties apply.  If none is
       given the installation properties apply to all target types.  If only
       one is given then only targets of that type will be installed (which
       can be used to install just a DLL or just an import library).

       One or more groups of properties may be specified in a single call to
       the TARGETS form of this command.  A target may be installed more than
       once to different locations.  Consider hypothetical targets "myExe",
       "mySharedLib", and "myStaticLib".  The code

           INSTALL(TARGETS myExe mySharedLib myStaticLib
                   RUNTIME DESTINATION bin
                   LIBRARY DESTINATION lib
                   ARCHIVE DESTINATION lib/static)
           INSTALL(TARGETS mySharedLib DESTINATION /some/full/path)

       will install myExe to <prefix>/bin and myStaticLib to
       <prefix>/lib/static.  On non-DLL platforms mySharedLib will be
       installed to <prefix>/lib and /some/full/path.  On DLL platforms the
       mySharedLib DLL will be installed to <prefix>/bin and /some/full/path
       and its import library will be installed to <prefix>/lib/static and
       /some/full/path.  On non-DLL platforms mySharedLib will be installed
       to <prefix>/lib and /some/full/path.

       The FILES signature:

         INSTALL(FILES files... DESTINATION <dir>
                 [PERMISSIONS permissions...]
                 [CONFIGURATIONS [Debug|Release|...]]
                 [COMPONENT <component>]
                 [RENAME <name>] [OPTIONAL])

       The FILES form specifies rules for installing files for a project.
       File names given as relative paths are interpreted with respect to the
       current source directory.  Files installed by this form are by default
       given permissions OWNER_WRITE, OWNER_READ, GROUP_READ, and WORLD_READ
       if no PERMISSIONS argument is given.

       The PROGRAMS signature:

         INSTALL(PROGRAMS files... DESTINATION <dir>
                 [PERMISSIONS permissions...]
                 [CONFIGURATIONS [Debug|Release|...]]
                 [COMPONENT <component>]
                 [RENAME <name>] [OPTIONAL])

       The PROGRAMS form is identical to the FILES form except that the
       default permissions for the installed file also include OWNER_EXECUTE,
       GROUP_EXECUTE, and WORLD_EXECUTE.  This form is intended to install
       programs that are not targets, such as shell scripts.  Use the TARGETS
       form to install targets built within the project.

       The DIRECTORY signature:

         INSTALL(DIRECTORY dirs... DESTINATION <dir>
                 [FILE_PERMISSIONS permissions...]
                 [DIRECTORY_PERMISSIONS permissions...]
                 [USE_SOURCE_PERMISSIONS]
                 [CONFIGURATIONS [Debug|Release|...]]
                 [COMPONENT <component>]
                 [[PATTERN <pattern> | REGEX <regex>]
                  [EXCLUDE] [PERMISSIONS permissions...]] [...])

       The DIRECTORY form installs contents of one or more directories to a
       given destination.  The directory structure is copied verbatim to the
       destination.  The last component of each directory name is appended to
       the destination directory but a trailing slash may be used to avoid
       this because it leaves the last component empty.  Directory names
       given as relative paths are interpreted with respect to the current
       source directory.  If no input directory names are given the
       destination directory will be created but nothing will be installed
       into it.  The FILE_PERMISSIONS and DIRECTORY_PERMISSIONS options
       specify permissions given to files and directories in the destination.
       If USE_SOURCE_PERMISSIONS is specified and FILE_PERMISSIONS is not,
       file permissions will be copied from the source directory structure.
       If no permissions are specified files will be given the default
       permissions specified in the FILES form of the command, and the
       directories will be given the default permissions specified in the
       PROGRAMS form of the command.  The PATTERN and REGEX options specify a
       globbing pattern or regular expression to match directories or files
       encountered during traversal of an input directory.  The full path to
       an input file or directory (with forward slashes) is matched against
       the expression.  A PATTERN will match only complete file names: the
       portion of the full path matching the pattern must occur at the end of
       the file name and be preceded by a slash.  A REGEX will match any
       portion of the full path but it may use '/' and '$' to simulate the
       PATTERN behavior.  Options following one of these matching expressions
       are applied only to files or directories matching them.  The EXCLUDE
       option will skip the matched file or directory.  The PERMISSIONS
       option overrides the permissions setting for the matched file or
       directory.  For example the code

         INSTALL(DIRECTORY icons scripts/ DESTINATION share/myproj
                 PATTERN "CVS" EXCLUDE
                 PATTERN "scripts/*"
                 PERMISSIONS OWNER_EXECUTE OWNER_WRITE OWNER_READ
                             GROUP_EXECUTE GROUP_READ)

       will install the icons directory to share/myproj/icons and the scripts
       directory to share/myproj.  The icons will get default file
       permissions, the scripts will be given specific permissions, and any
       CVS directories will be excluded.

       The SCRIPT and CODE signature:

         INSTALL([[SCRIPT <file>] [CODE <code>]] [...])

       The SCRIPT form will invoke the given CMake script files during
       installation.  If the script file name is a relative path it will be
       interpreted with respect to the current source directory.  The CODE
       form will invoke the given CMake code during installation.  Code is
       specified as a single argument inside a double-quoted string.  For
       example, the code

         INSTALL(CODE "MESSAGE(\"Sample install message.\")")

       will print a message during installation.

       NOTE: This command supercedes the INSTALL_TARGETS command and the
       target properties PRE_INSTALL_SCRIPT and POST_INSTALL_SCRIPT.  It also
       replaces the FILES forms of the INSTALL_FILES and INSTALL_PROGRAMS
       commands.  The processing order of these install rules relative to
       those generated by INSTALL_TARGETS, INSTALL_FILES, and
       INSTALL_PROGRAMS commands is not defined.


  INSTALL_FILES
       Old installation command.  Use the INSTALL command.

       This command has been superceded by the INSTALL command.  It is
       provided for compatibility with older CMake code.  The FILES form is
       directly replaced by the FILES form of the INSTALL command.  The
       regexp form can be expressed more clearly using the GLOB form of the
       FILE command.

         INSTALL_FILES(<dir> extension file file ...)

       Create rules to install the listed files with the given extension into
       the given directory.  Only files existing in the current source tree
       or its corresponding location in the binary tree may be listed.  If a
       file specified already has an extension, that extension will be
       removed first.  This is useful for providing lists of source files
       such as foo.cxx when you want the corresponding foo.h to be installed.
       A typical extension is '.h'.

         INSTALL_FILES(<dir> regexp)

       Any files in the current source directory that match the regular
       expression will be installed.

         INSTALL_FILES(<dir> FILES file file ...)

       Any files listed after the FILES keyword will be installed explicitly
       from the names given.  Full paths are allowed in this form.

       The directory <dir> is relative to the installation prefix, which is
       stored in the variable CMAKE_INSTALL_PREFIX.

  INSTALL_PROGRAMS
       Old installation command.  Use the INSTALL command.

       This command has been superceded by the INSTALL command.  It is
       provided for compatibility with older CMake code.  The FILES form is
       directly replaced by the PROGRAMS form of the INSTALL command.  The
       regexp form can be expressed more clearly using the GLOB form of the
       FILE command.

         INSTALL_PROGRAMS(<dir> file1 file2 [file3 ...])
         INSTALL_PROGRAMS(<dir> FILES file1 [file2 ...])

       Create rules to install the listed programs into the given directory.
       Use the FILES argument to guarantee that the file list version of the
       command will be used even when there is only one argument.

         INSTALL_PROGRAMS(<dir> regexp)

       In the second form any program in the current source directory that
       matches the regular expression will be installed.

       This command is intended to install programs that are not built by
       cmake, such as shell scripts.  See the TARGETS form of the INSTALL
       command to create installation rules for targets built by cmake.

       The directory <dir> is relative to the installation prefix, which is
       stored in the variable CMAKE_INSTALL_PREFIX.

  INSTALL_TARGETS
       Old installation command.  Use the INSTALL command.

       This command has been superceded by the INSTALL command.  It is
       provided for compatibility with older CMake code.

         INSTALL_TARGETS(<dir> [RUNTIME_DIRECTORY dir] target target)

       Create rules to install the listed targets into the given directory.
       The directory <dir> is relative to the installation prefix, which is
       stored in the variable CMAKE_INSTALL_PREFIX.  If RUNTIME_DIRECTORY is
       specified, then on systems with special runtime files (Windows DLL),
       the files will be copied to that directory.

  LINK_DIRECTORIES
       Specify directories in which to search for libraries.

         LINK_DIRECTORIES(directory1 directory2 ...)

       Specify the paths in which the linker should search for libraries.

  LINK_LIBRARIES
       Link libraries to all targets added later.

         LINK_LIBRARIES(library1 <debug | optimized> library2 ...)

       This is an old CMake command for linking libraries.  Use
       TARGET_LINK_LIBRARIES unless you have a good reason for every target
       to link to the same set of libraries.

       Specify a list of libraries to be linked into any following targets
       (typically added with the ADD_EXECUTABLE or ADD_LIBRARY calls).  This
       command is passed down to all subdirectories.  The debug and optimized
       strings may be used to indicate that the next library listed is to be
       used only for that specific type of build.

  LIST
       List operations.

         LIST(LENGTH <list> <output variable>)
         LIST(GET <list> <element index> [<element index> ...] <output variable>)
         LIST(APPEND <list> <element> [<element> ...])
         LIST(INSERT <list> <element_index> <element> [<element> ...])
         LIST(REMOVE_ITEM <list> <value> [<value> ...])
         LIST(REMOVE_AT <list> <index> [<index> ...])
         LIST(SORT <list>)
         LIST(REVERSE <list>)

       LENGTH will return a given list's length.

       GET will return list of elements specified by indices from the list.

       APPEND will append elements to the list.

       INSERT will insert elements to the list to the specified location.

       When specifying an index, negative value corresponds to index from the
       end of the list.

       REMOVE_AT and REMOVE_ITEM will remove item from the list.  The
       difference is that REMOVE_ITEM will remove the given items, while
       REMOVE_AT will remove the item at the given indices.


  LOAD_CACHE
       Load in the values from another project's CMake cache.

         LOAD_CACHE(pathToCacheFile READ_WITH_PREFIX
                    prefix entry1...)

       Read the cache and store the requested entries in variables with their
       name prefixed with the given prefix.  This only reads the values, and
       does not create entries in the local project's cache.

         LOAD_CACHE(pathToCacheFile [EXCLUDE entry1...]
                    [INCLUDE_INTERNALS entry1...])

       Load in the values from another cache and store them in the local
       project's cache as internal entries.  This is useful for a project
       that depends on another project built in a different tree.  EXCLUDE
       option can be used to provide a list of entries to be excluded.
       INCLUDE_INTERNALS can be used to provide a list of internal entries to
       be included.  Normally, no internal entries are brought in.  Use of
       this form of the command is strongly discouraged, but it is provided
       for backward compatibility.

  LOAD_COMMAND
       Load a command into a running CMake.

         LOAD_COMMAND(COMMAND_NAME <loc1> [loc2 ...])

       The given locations are searched for a library whose name is
       cmCOMMAND_NAME.  If found, it is loaded as a module and the command is
       added to the set of available CMake commands.  Usually, TRY_COMPILE is
       used before this command to compile the module.  If the command is
       successfully loaded a variable named

         CMAKE_LOADED_COMMAND_<COMMAND_NAME>

       will be set to the full path of the module that was loaded.  Otherwise
       the variable will not be set.

  MACRO
       Start recording a macro for later invocation as a command.

         MACRO(<name> [arg1 [arg2 [arg3 ...]]])
           COMMAND1(ARGS ...)
           COMMAND2(ARGS ...)
           ...
         ENDMACRO(<name>)

       Define a macro named <name> that takes arguments named arg1 arg2 arg3
       (...).  Commands listed after MACRO, but before the matching ENDMACRO,
       are not invoked until the macro is invoked.  When it is invoked, the
       commands recorded in the macro are first modified by replacing formal
       parameters (${arg1}) with the arguments passed, and then invoked as
       normal commands.  In addition to referencing the formal parameters you
       can reference the variable ARGC which will be set to the number of
       arguments passed into the function as well as ARGV0 ARGV1 ARGV2 ...
       which will have the actual values of the arguments passed in.  This
       facilitates creating macros with optional arguments.  Additionally
       ARGV holds the list of all arguments given to the macro and ARGN holds
       the list of argument pass the last expected argument.

  MAKE_DIRECTORY
       Old directory creation command.  Use the FILE command.

       This command has been superceded by the FILE(MAKE_DIRECTORY ...)
       command.  It is provided for compatibility with older CMake code.

         MAKE_DIRECTORY(directory)

       Creates the specified directory.  Full paths should be given.  Any
       parent directories that do not exist will also be created.  Use with
       care.

  MARK_AS_ADVANCED
       Mark cmake cached variables as advanced.

         MARK_AS_ADVANCED([CLEAR|FORCE] VAR VAR2 VAR...)

       Mark the named cached variables as advanced.  An advanced variable
       will not be displayed in any of the cmake GUIs unless the show
       advanced option is on.  If CLEAR is the first argument advanced
       variables are changed back to unadvanced.  If FORCE is the first
       argument, then the variable is made advanced.  If neither FORCE nor
       CLEAR is specified, new values will be marked as advanced, but if the
       variable already has an advanced/non-advanced state, it will not be
       changed.

  MATH
       Mathematical expressions.

         MATH(EXPR <output variable> <math expression>)

       EXPR evaluates mathematical expression and return result in the output
       variable.  Example mathematical expression is '5 * ( 10 + 13 )'.

  MESSAGE
       Display a message to the user.

         MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR]
                 "message to display" ...)

       By default the message is displayed in a pop up window (CMakeSetup),
       or in the stdout of cmake, or the error section of ccmake.  If the
       first argument is SEND_ERROR then an error is raised, and the generate
       phase will be skipped.  If the first argument is FATAL_ERROR, all
       processing is halted.  If the first argument is STATUS then the
       message is displayed in the progress line for the GUI, or with a -- in
       the command line cmake.

  OPTION
       Provides an option that the user can optionally select.

         OPTION(OPTION_VAR "help string describing option"
                [initial value])

       Provide an option for the user to select as ON or OFF.  If no initial
       value is provided, OFF is used.

  OUTPUT_REQUIRED_FILES
       Output a list of required source files for a specified source file.

         OUTPUT_REQUIRED_FILES(srcfile outputfile)

       Outputs a list of all the source files that are required by the
       specified srcfile.  This list is written into outputfile.  This is
       similar to writing out the dependencies for srcfile except that it
       jumps from .h files into .cxx, .c and .cpp files if possible.

  PROJECT
       Set a name for the entire project.

         PROJECT(projectname [CXX] [C] [Java])

       Sets the name of the project.  This creates the variables
       projectname_BINARY_DIR and projectname_SOURCE_DIR.  Optionally you can
       specify which languages your project supports.  By default all
       languages are supported.  If you do not have a C++ compiler, but want
       to build a c program with cmake, then use this option.

  QT_WRAP_CPP
       Create QT Wrappers.

         QT_WRAP_CPP(resultingLibraryName DestName
                     SourceLists ...)

       Produce moc files for all the .h files listed in the SourceLists.  The
       moc files will be added to the library using the DestName source list.

  QT_WRAP_UI
       Create QT user interfaces Wrappers.

         QT_WRAP_UI(resultingLibraryName HeadersDestName
                    SourcesDestName SourceLists ...)

       Produce .h and .cxx files for all the .ui files listed in the
       SourceLists.  The .h files will be added to the library using the
       HeadersDestNamesource list.  The .cxx files will be added to the
       library using the SourcesDestNamesource list.

  REMOVE
       Old list item removal command.  Use the LIST command.

       This command has been superceded by the LIST(REMOVE ...) command.  It
       is provided for compatibility with older CMake code.

         REMOVE(VAR VALUE VALUE ...)

       Removes VALUE from the variable VAR.  This is typically used to remove
       entries from a vector (e.g.  semicolon separated list).  VALUE is
       expanded.

  REMOVE_DEFINITIONS
       Removes -D define flags to the command line of C and C++ compilers.

         REMOVE_DEFINITIONS(-DFOO -DBAR ...)

       Removes flags from command line of C and C++ compilers.  This command
       can be used to remove any flag from a compile line, but the -D flag is
       accepted most C/C++ compilers.  Other flags may not be as portable.

  SEPARATE_ARGUMENTS
       Split space separated arguments into a semi-colon separated list.

         SEPARATE_ARGUMENTS(VARIABLE)

       Convert the value of VARIABLE to a semi-colon separated list.  All
       spaces are replaced with ';'.  This helps with generating command
       lines.

  SET
       Set a CMAKE variable to a given value.

         SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])

       Within CMake sets VAR to the value VALUE.  VALUE is expanded before
       VAR is set to it.  If CACHE is present, then the VAR is put in the
       cache.  TYPE and DOCSTRING are required.  TYPE is used by the CMake
       GUI to choose a widget with which the user sets a value.  The value
       for TYPE may be one of

         FILEPATH = File chooser dialog.
         PATH     = Directory chooser dialog.
         STRING   = Arbitrary string.
         BOOL     = Boolean ON/OFF checkbox.
         INTERNAL = No GUI entry (used for persistent variables).

       If TYPE is INTERNAL, then the VALUE is always written into the cache,
       replacing any values existing in the cache.  If it is not a cache
       variable, then this always writes into the current makefile.  The
       FORCE option will overwrite the cache value removing any changes by
       the user.

         SET(VAR VALUE1 ... VALUEN).

       In this case VAR is set to a semicolon separated list of values.

       VAR can be an environment variable such as:

         SET( ENV{PATH} /home/martink )

       in which case the environment variable will be set.

  SET_DIRECTORY_PROPERTIES
       Set a property of the directory.

         SET_DIRECTORY_PROPERTIES(PROPERTIES prop1 value1 prop2 value2)

       Set a property for the current directory and subdirectories.  If the
       property is not found, CMake will report an error.  The properties
       include: INCLUDE_DIRECTORIES, LINK_DIRECTORIES,
       INCLUDE_REGULAR_EXPRESSION, and ADDITIONAL_MAKE_CLEAN_FILES.

       ADDITIONAL_MAKE_CLEAN_FILES is a list of files that will be cleaned as
       a part of "make clean" stage.

  SET_SOURCE_FILES_PROPERTIES
       Source files can have properties that affect how they are built.

         SET_SOURCE_FILES_PROPERTIES(file1 file2 ...
                                     PROPERTIES prop1 value1
                                     prop2 value2 ...)

       Set properties on a file.  The syntax for the command is to list all
       the files you want to change, and then provide the values you want to
       set next.  You can make up your own properties as well.  The following
       are used by CMake.  The ABSTRACT flag (boolean) is used by some class
       wrapping commands.  If WRAP_EXCLUDE (boolean) is true then many
       wrapping commands will ignore this file.  If GENERATED (boolean) is
       true then it is not an error if this source file does not exist when
       it is added to a target.  Obviously, it must be created (presumably by
       a custom command) before the target is built.  If the HEADER_FILE_ONLY
       (boolean) property is true then dependency information is not created
       for that file (this is set automatically, based on the file's name's
       extension and is probably only used by Makefiles).  OBJECT_DEPENDS
       (string) adds dependencies to the object file.  COMPILE_FLAGS (string)
       is passed to the compiler as additional command line arguments when
       the source file is compiled.  If SYMBOLIC (boolean) is set to true the
       build system will be informed that the source file is not actually
       created on disk but instead used as a symbolic name for a build rule.

  SET_TARGET_PROPERTIES
       Targets can have properties that affect how they are built.

         SET_TARGET_PROPERTIES(target1 target2 ...
                               PROPERTIES prop1 value1
                               prop2 value2 ...)

       Set properties on a target.  The syntax for the command is to list all
       the files you want to change, and then provide the values you want to
       set next.  You can use any prop value pair you want and extract it
       later with the GET_TARGET_PROPERTY command.

       Properties that affect the name of a target's output file are as
       follows.  The PREFIX and SUFFIX properties override the default target
       name prefix (such as "lib") and suffix (such as ".so").  IMPORT_PREFIX
       and IMPORT_SUFFIX are the equivalent properties for the import library
       corresponding to a DLL (for SHARED library targets).  OUTPUT_NAME sets
       the real name of a target when it is built and can be used to help
       create two targets of the same name even though CMake requires unique
       logical target names.  There is also a <CONFIG>_OUTPUT_NAME that can
       set the output name on a per-configuration basis.  <CONFIG>_POSTFIX
       sets a postfix for the real name of the target when it is built under
       the configuration named by <CONFIG> (in upper-case, such as
       "DEBUG_POSTFIX").  The value of this property is initialized when the
       target is created to the value of the variable CMAKE_<CONFIG>_POSTFIX
       (except for executable targets because earlier CMake versions which
       did not use this variable for executables).

       The LINK_FLAGS property can be used to add extra flags to the link
       step of a target.  LINK_FLAGS_<CONFIG> will add to the configuration
       <CONFIG>, for example, DEBUG, RELEASE, MINSIZEREL, RELWITHDEBINFO.
       DEFINE_SYMBOL sets the name of the preprocessor symbol defined when
       compiling sources in a shared library.  If not set here then it is set
       to target_EXPORTS by default (with some substitutions if the target is
       not a valid C identifier).  This is useful for headers to know whether
       they are being included from inside their library our outside to
       properly setup dllexport/dllimport decorations.  The COMPILE_FLAGS
       property sets additional compiler flags used to build sources within
       the target.  It may also be used to pass additional preprocessor
       definitions.

       The LINKER_LANGUAGE property is used to change the tool used to link
       an executable or shared library.  The default is set the language to
       match the files in the library.  CXX and C are common values for this
       property.

       For shared libraries VERSION and SOVERSION can be used to specify the
       build version and api version respectively.  When building or
       installing appropriate symlinks are created if the platform supports
       symlinks and the linker supports so-names.  If only one of both is
       specified the missing is assumed to have the same version number.  For
       executables VERSION can be used to specify the build version.  When
       building or installing appropriate symlinks are created if the
       platform supports symlinks.  For shared libraries and executables on
       Windows the VERSION attribute is parsed to extract a "major.minor"
       version number.  These numbers are used as the image version of the
       binary.

       There are a few properties used to specify RPATH rules.  INSTALL_RPATH
       is a semicolon-separated list specifying the rpath to use in installed
       targets (for platforms that support it).  INSTALL_RPATH_USE_LINK_PATH
       is a boolean that if set to true will append directories in the linker
       search path and outside the project to the INSTALL_RPATH.
       SKIP_BUILD_RPATH is a boolean specifying whether to skip automatic
       generation of an rpath allowing the target to run from the build tree.
       BUILD_WITH_INSTALL_RPATH is a boolean specifying whether to link the
       target in the build tree with the INSTALL_RPATH.  This takes
       precedence over SKIP_BUILD_RPATH and avoids the need for relinking
       before installation.  INSTALL_NAME_DIR is a string specifying the
       directory portion of the "install_name" field of shared libraries on
       Mac OSX to use in the installed targets.  When the target is created
       the values of the variables CMAKE_INSTALL_RPATH,
       CMAKE_INSTALL_RPATH_USE_LINK_PATH, CMAKE_SKIP_BUILD_RPATH,
       CMAKE_BUILD_WITH_INSTALL_RPATH, and CMAKE_INSTALL_NAME_DIR are used to
       initialize these properties.

       PROJECT_LABEL can be used to change the name of the target in an IDE
       like visual studio.  VS_KEYWORD can be set to change the visual studio
       keyword, for example QT integration works better if this is set to
       Qt4VSv1.0.

       When a library is built CMake by default generates code to remove any
       existing library using all possible names.  This is needed to support
       libraries that switch between STATIC and SHARED by a user option.
       However when using OUTPUT_NAME to build a static and shared library of
       the same name using different logical target names the two targets
       will remove each other's files.  This can be prevented by setting the
       CLEAN_DIRECT_OUTPUT property to 1.

       The PRE_INSTALL_SCRIPT and POST_INSTALL_SCRIPT properties are the old
       way to specify CMake scripts to run before and after installing a
       target.  They are used only when the old INSTALL_TARGETS command is
       used to install the target.  Use the INSTALL command instead.

       The EXCLUDE_FROM_DEFAULT_BUILD property is used by the visual studio
       generators.  If it is set to 1 the target will not be part of the
       default build when you select "Build Solution".

  SET_TESTS_PROPERTIES
       Set a property of the tests.

         SET_TESTS_PROPERTIES(test1 [test2...] PROPERTIES prop1 value1 prop2 value2)

       Set a property for the tests.  If the property is not found, CMake
       will report an error.  The properties include:

       WILL_FAIL: If set to true, this will invert the pass/fail flag of the
       test.

       PASS_REGULAR_EXPRESSION: If set, the test output will be checked
       against the specified regular expressions and at least one of the
       regular expressions has to match, otherwise the test will fail.

         Example: PASS_REGULAR_EXPRESSION "TestPassed;All ok"

       FAIL_REGULAR_EXPRESSION: If set, if the output will match to one of
       specified regular expressions, the test will fail.

         Example: PASS_REGULAR_EXPRESSION "[^a-z]Error;ERROR;Failed"

       Both PASS_REGULAR_EXPRESSION and FAIL_REGULAR_EXPRESSION expect a list
       of regular expressions.


  SITE_NAME
       Set the given variable to the name of the computer.

         SITE_NAME(variable)


  SOURCE_GROUP
       Define a grouping for sources in the makefile.

         SOURCE_GROUP(name [REGULAR_EXPRESSION regex] [FILES src1 src2 ...])

       Defines a group into which sources will be placed in project files.
       This is mainly used to setup file tabs in Visual Studio.  Any file
       whose name is listed or matches the regular expression will be placed
       in this group.  If a file matches multiple groups, the LAST group that
       explicitly lists the file will be favored, if any.  If no group
       explicitly lists the file, the LAST group whose regular expression
       matches the file will be favored.

       The name of the group may contain backslashes to specify subgroups:

         SOURCE_GROUP(outer\\inner ...)

       For backwards compatibility, this command is also supports the format:

         SOURCE_GROUP(name regex)

  STRING
       String operations.

         STRING(REGEX MATCH <regular_expression>
                <output variable> <input> [<input>...])
         STRING(REGEX MATCHALL <regular_expression>
                <output variable> <input> [<input>...])
         STRING(REGEX REPLACE <regular_expression>
                <replace_expression> <output variable>
                <input> [<input>...])
         STRING(REPLACE <match_expression>
                <replace_expression> <output variable>
                <input> [<input>...])
         STRING(COMPARE EQUAL <string1> <string2> <output variable>)
         STRING(COMPARE NOTEQUAL <string1> <string2> <output variable>)
         STRING(COMPARE LESS <string1> <string2> <output variable>)
         STRING(COMPARE GREATER <string1> <string2> <output variable>)
         STRING(ASCII <number> [<number> ...] <output variable>)
         STRING(CONFIGURE <string1> <output variable>
                [@ONLY] [ESCAPE_QUOTES])
         STRING(TOUPPER <string1> <output variable>)
         STRING(TOLOWER <string1> <output variable>)
         STRING(LENGTH <string> <output variable>)
         STRING(SUBSTRING <string> <begin> <length> <output variable>)

       REGEX MATCH will match the regular expression once and store the match
       in the output variable.

       REGEX MATCHALL will match the regular expression as many times as
       possible and store the matches in the output variable as a list.

       REGEX REPLACE will match the regular expression as many times as
       possible and substitute the replacement expression for the match in
       the output.  The replace expression may refer to paren-delimited
       subexpressions of the match using \1, \2, ..., \9.  Note that two
       backslashes (\\1) are required in CMake code to get a backslash
       through argument parsing.

       REPLACE will match the given expression and substitute the replacement
       expression for the match in the output.  The replace expression may
       refer to paren-delimited subexpressions of the match using \1, \2,
       ..., \9.  Note that two backslashes (\\1) are required in CMake code
       to get a backslash through argument parsing.

       COMPARE EQUAL/NOTEQUAL/LESS/GREATER will compare the strings and store
       true or false in the output variable.

       ASCII will convert all numbers into corresponding ASCII characters.

       CONFIGURE will transform a string like CONFIGURE_FILE transforms a
       file.

       TOUPPER/TOLOWER will convert string to upper/lower characters.

       LENGTH will return a given string's length.

       SUBSTRING will return a substring of a given string.

  SUBDIR_DEPENDS
       Legacy command.  Does nothing.

         SUBDIR_DEPENDS(subdir dep1 dep2 ...)

       Does not do anything.  This command used to help projects order
       parallel builds correctly.  This functionality is now automatic.

  SUBDIRS
       Add a list of subdirectories to the build.

         SUBDIRS(dir1 dir2 ...[EXCLUDE_FROM_ALL exclude_dir1 exclude_dir2 ...] [PREORDER] )

       Add a list of subdirectories to the build.  The ADD_SUBDIRECTORY
       command should be used instead of SUBDIRS although SUBDIRS will still
       work.  This will cause any CMakeLists.txt files in the sub directories
       to be processed by CMake.  Any directories after the PREORDER flag are
       traversed first by makefile builds, the PREORDER flag has no effect on
       IDE projects.  Any directories after the EXCLUDE_FROM_ALL marker will
       not be included in the top level makefile or project file.  This is
       useful for having CMake create makefiles or projects for a set of
       examples in a project.  You would want CMake to generate makefiles or
       project files for all the examples at the same time, but you would not
       want them to show up in the top level project or be built each time
       make is run from the top.

  TARGET_LINK_LIBRARIES
       Link a target to given libraries.

         TARGET_LINK_LIBRARIES(target library1
                               <debug | optimized> library2
                               ...)

       Specify a list of libraries to be linked into the specified target.
       The debug and optimized strings may be used to indicate that the next
       library listed is to be used only for that specific type of build

  TRY_COMPILE
       Try compiling some code.

         TRY_COMPILE(RESULT_VAR bindir srcdir
                     projectName <targetname> <CMAKE_FLAGS <Flags>>
                     <OUTPUT_VARIABLE var>)

       Try compiling a program.  Return the success or failure in RESULT_VAR.
       If <target name> is specified then build just that target otherwise
       the all or ALL_BUILD target is built.

         TRY_COMPILE(RESULT_VAR bindir srcfile
                     <CMAKE_FLAGS <Flags>>
                     <COMPILE_DEFINITIONS <flags> ...>
                     <OUTPUT_VARIABLE var>)

       Try compiling a srcfile.  Return the success or failure in RESULT_VAR.
       CMAKE_FLAGS can be used to pass -DVAR:TYPE=VALUE flags to cmake.  Some
       extra flags that can be included are, INCLUDE_DIRECTORIES,
       LINK_DIRECTORIES, and LINK_LIBRARIES.  COMPILE_DEFINITIONS are
       -Ddefinition that will be passed to the compile line.  If srcfile is
       specified the files in bindir/CMakeFiles/CMakeTmp are cleaned
       automatically.  If OUTPUT_VARIABLE is specified, then the output from
       the build process is stored in the given variable.  TRY_COMPILE
       creates a CMakeList.txt file on the fly, and in that file it looks
       like this:

         ADD_DEFINITIONS( <expanded COMPILE_DEFINITIONS from calling cmake>)
         INCLUDE_DIRECTORIES(${INCLUDE_DIRECTORIES})
         LINK_DIRECTORIES(${LINK_DIRECTORIES})
         ADD_EXECUTABLE(cmTryCompileExec sources)
         TARGET_LINK_LIBRARIES(cmTryCompileExec ${LINK_LIBRARIES})


  TRY_RUN
       Try compiling and then running some code.

         TRY_RUN(RUN_RESULT_VAR COMPILE_RESULT_VAR
                 bindir srcfile <CMAKE_FLAGS <Flags>>
                 <COMPILE_DEFINITIONS <flags>>
                 <OUTPUT_VARIABLE var>
                 <ARGS <arg1> <arg2>...>)

       Try compiling a srcfile.  Return the success or failure in
       COMPILE_RESULT_VAR.  Then if the compile succeeded, run the executable
       and return the result in RUN_RESULT_VAR.  If the executable was built,
       but failed for to run for some reason, then RUN_RESULT_VAR will be set
       to FAILED_TO_RUN, and the output will be in the COMPILE_RESULT_VAR.
       OUTPUT_VARIABLE specifies the name of the variable to put all of the
       standard output and standard error into.

  USE_MANGLED_MESA
       Copy mesa headers for use in combination with system GL.

         USE_MANGLED_MESA(PATH_TO_MESA OUTPUT_DIRECTORY)

       The path to mesa includes, should contain gl_mangle.h.  The mesa
       headers are copied to the specified output directory.  This allows
       mangled mesa headers to override other GL headers by being added to
       the include directory path earlier.

  UTILITY_SOURCE
       Specify the source tree of a third-party utility.

         UTILITY_SOURCE(cache_entry executable_name
                        path_to_source [file1 file2 ...])

       When a third-party utility's source is included in the distribution,
       this command specifies its location and name.  The cache entry will
       not be set unless the path_to_source and all listed files exist.  It
       is assumed that the source tree of the utility will have been built
       before it is needed.

  VARIABLE_REQUIRES
       Assert satisfaction of an option's required variables.

         VARIABLE_REQUIRES(TEST_VARIABLE RESULT_VARIABLE
                           REQUIRED_VARIABLE1
                           REQUIRED_VARIABLE2 ...)

       The first argument (TEST_VARIABLE) is the name of the variable to be
       tested, if that variable is false nothing else is done.  If
       TEST_VARIABLE is true, then the next argument (RESULT_VARIABLE) is a
       variable that is set to true if all the required variables are set.
       The rest of the arguments are variables that must be true or not set
       to NOTFOUND to avoid an error.  If any are not true, an error is
       reported.

  VTK_MAKE_INSTANTIATOR
       Deprecated.  For use only in VTK 4.0.

         VTK_MAKE_INSTANTIATOR(className outSourceList
                               src-list1 [src-list2 ..]
                               EXPORT_MACRO exportMacro
                               [HEADER_LOCATION dir]
                               [GROUP_SIZE groupSize]
                               [INCLUDES [file1 file2 ..]])

       Generates a new class with the given name and adds its files to the
       given outSourceList.  It registers the classes from the other given
       source lists with vtkInstantiator when it is loaded.  The output
       source list should be added to the library with the classes it
       registers.  The EXPORT_MACRO argument must be given and followed by
       the export macro to use when generating the class (ex.
       VTK_COMMON_EXPORT).  The HEADER_LOCATION option must be followed by a
       path.  It specifies the directory in which to place the generated
       class's header file.  The generated class implementation files always
       go in the build directory corresponding to the CMakeLists.txt file
       containing the command.  This is the default location for the header.
       The INCLUDES option can be followed by a list of zero or more files.
       These files will be #included by the generated instantiator header,
       and can be used to gain access to the specified exportMacro in the C++
       code.

  VTK_WRAP_JAVA
       Deprecated.  For use only in VTK 4.0.

         VTK_WRAP_JAVA(resultingLibraryName SourceListName
                       class1 class2 ...)

       Create Java wrappers for VTK classes.

  VTK_WRAP_PYTHON
       Deprecated.  For use only in VTK 4.0.

         VTK_WRAP_PYTHON(resultingLibraryName SourceListName
                         class1 class2 ...)

       Create Python wrappers for VTK classes.

  VTK_WRAP_TCL
       Deprecated.  For use only in VTK 4.0.

         VTK_WRAP_TCL(resultingLibraryName [SOURCES]
                      SourceListName class1 class2 ...
                      [COMMANDS CommandName1 CommandName2 ...])

       Create Tcl wrappers for VTK classes.

  WHILE
       Evaluate a group of commands while a condition is true

         WHILE(condition)
           COMMAND1(ARGS ...)
           COMMAND2(ARGS ...)
           ...
         ENDWHILE(condition)

       All commands between WHILE and the matching ENDWHILE are recorded
       without being invoked.  Once the ENDWHILE is evaluated, the recorded
       list of commands is invoked as long as the condition is true.  The
       condition is evaulated using the same logic as the IF command.

  WRITE_FILE
       Write a message to a file.

         WRITE_FILE(filename "message to write"... [APPEND])

       The first argument is the file name, the rest of the arguments are
       messages to write.  If the argument APPEND is specified, then the
       message will be appended.

       NOTE 1: FILE WRITE and FILE APPEND do exactly the same as this one but
       add some more functionality.

       NOTE 2: When using WRITE_FILE the produced file cannot be used as an
       input to CMake (CONFIGURE_FILE, source file ...) because it will lead
       to an infinite loop.  Use CONFIGURE_FILE if you want to generate input
       files to CMake.

------------------------------------------------------------------------------
Standard CMake Modules

The following modules are provided with CMake.  They can be used with
INCLUDE(ModuleName).

------------------------------------------------------------------------------
Copyright

Copyright (c) 2002 Kitware, Inc., Insight Consortium.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

       Redistributions of source code must retain the above copyright notice,
       this list of conditions and the following disclaimer.

       Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in the
       documentation and/or other materials provided with the distribution.

       The names of Kitware, Inc., the Insight Consortium, or the names of
       any consortium members, or of any contributors, may not be used to
       endorse or promote products derived from this software without
       specific prior written permission.

       Modified source versions must be plainly marked as such, and must not
       be misrepresented as being the original software.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

------------------------------------------------------------------------------
See Also

The following resources are available to get help using CMake:

  Home Page
       http://www.cmake.org

       The primary starting point for learning about CMake.

  Frequently Asked Questions
       http://www.cmake.org/Wiki/CMake_FAQ

       A Wiki is provided containing answers to frequently asked questions.

  Online Documentation
       http://www.cmake.org/HTML/Documentation.html

       Links to available documentation may be found on this web page.

  Mailing List
       http://www.cmake.org/HTML/MailingLists.html

       For help and discussion about using cmake, a mailing list is provided
       at cmake@cmake.org.  The list is member-post-only but one may sign up
       on the CMake web page.  Please first read the full documentation at
       http://www.cmake.org before posting questions to the list.

Summary of helpful links:

  Home: http://www.cmake.org
  Docs: http://www.cmake.org/HTML/Documentation.html
  Mail: http://www.cmake.org/HTML/MailingLists.html
  FAQ:  http://www.cmake.org/Wiki/CMake_FAQ


