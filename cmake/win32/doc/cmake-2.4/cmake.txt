cmake version 2.4-patch 6
------------------------------------------------------------------------------
Name

  cmake - Cross-Platform Makefile Generator.

------------------------------------------------------------------------------
Usage

  cmake [options] <path-to-source>
  cmake [options] <path-to-existing-build>

The "cmake" executable is the CMake command-line interface.  It may be used
to configure projects in scripts.  Project configuration settings may be
specified on the command line with the -D option.  The -i option will cause
cmake to interactively prompt for such settings.

CMake is a cross-platform build system generator.  Projects specify their
build process with platform-independent CMake listfiles included in each
directory of a source tree with the name CMakeLists.txt.  Users build a
project by using CMake to generate a build system for a native tool on their
platform.

------------------------------------------------------------------------------
Command-Line Options

  -C <initial-cache>
       Pre-load a script to populate the cache.

       When cmake is first run in an empty build tree, it creates a
       CMakeCache.txt file and populates it with customizable settings for
       the project.  This option may be used to specify a file from which to
       load cache entries before the first pass through the project's cmake
       listfiles.  The loaded entries take priority over the project's
       default values.  The given file should be a CMake script containing
       SET commands that use the CACHE option, not a cache-format file.

  -D <var>:<type>=<value>
       Create a cmake cache entry.

       When cmake is first run in an empty build tree, it creates a
       CMakeCache.txt file and populates it with customizable settings for
       the project.  This option may be used to specify a setting that takes
       priority over the project's default value.  The option may be repeated
       for as many cache entries as desired.

  -G <generator-name>
       Specify a makefile generator.

       CMake may support multiple native build systems on certain platforms.
       A makefile generator is responsible for generating a particular build
       system.  Possible generator names are specified in the Generators
       section.

  -E
       CMake command mode.

       For true platform independence, CMake provides a list of commands that
       can be used on all systems.  Run with -E help for the usage
       information.

  -i
       Run in wizard mode.

       Wizard mode runs cmake interactively without a GUI.  The user is
       prompted to answer questions about the project configuration.  The
       answers are used to set cmake cache values.

  -L[A][H]
       List non-advanced cached variables.

       List cache variables will run CMake and list all the variables from
       the CMake cache that are not marked as INTERNAL or ADVANCED.  This
       will effectively display current CMake settings, which can be then
       changed with -D option.  Changing some of the variable may result in
       more variables being created.  If A is specified, then it will display
       also advanced variables.  If H is specified, it will also display help
       for each variable.

  -N
       View mode only.

       Only load the cache.  Do not actually run configure and generate
       steps.

  -P <file>
       Process script mode.

       Process the given cmake file as a script written in the CMake
       language.  No configure or generate step is performed and the cache is
       not modified.

  --graphviz=[file]
       Generate graphviz of dependencies.

       Generate a graphviz input file that will contain all the library and
       executable dependencies in the project.

  --debug-trycompile
       Do not delete the try compile directories..

       Do not delete the files and directories created for try_compile calls.
       This is useful in debugging failed try_compiles.

  --debug-output
       Put cmake in a debug mode.

       Print extra stuff during the cmake run like stack traces with
       message(send_error ) calls.

  --help-command cmd [file]
       Print help for a single command and exit.

       Full documentation specific to the given command is displayed.

  --help-command-list [file]
       List available listfile commands and exit.

       The list contains all commands for which help may be obtained by using
       the --help-command argument followed by a command name.  If a file is
       specified, the help is written into it.

  --help-module module [file]
       Print help for a single module and exit.

       Full documentation specific to the given module is displayed.

  --help-module-list [file]
       List available modules and exit.

       The list contains all modules for which help may be obtained by using
       the --help-module argument followed by a module name.  If a file is
       specified, the help is written into it.

  --copyright [file]
       Print the CMake copyright and exit.

       If a file is specified, the copyright is written into it.

  --help
       Print usage information and exit.

       Usage describes the basic command line interface and its options.

  --help-full [file]
       Print full help and exit.

       Full help displays most of the documentation provided by the UNIX man
       page.  It is provided for use on non-UNIX platforms, but is also
       convenient if the man page is not installed.  If a file is specified,
       the help is written into it.

  --help-html [file]
       Print full help in HTML format.

       This option is used by CMake authors to help produce web pages.  If a
       file is specified, the help is written into it.

  --help-man [file]
       Print a UNIX man page and exit.

       This option is used by the cmake build to generate the UNIX man page.
       If a file is specified, the help is written into it.

  --version [file]
       Show program name/version banner and exit.

       If a file is specified, the version is written into it.

------------------------------------------------------------------------------
Generators

The following generators are available on this platform:

  Borland Makefiles
       Generates Borland makefiles.


  MSYS Makefiles
       Generates MSYS makefiles.

       The makefiles use /bin/sh as the shell.  They require msys to be
       installed on the machine.

  MinGW Makefiles
       Generates a make file for use with mingw32-make.

       The makefiles generated use cmd.exe as the shell.  They do not require
       msys or a unix shell.

  NMake Makefiles
       Generates NMake makefiles.


  Unix Makefiles
       Generates standard UNIX makefiles.

       A hierarchy of UNIX makefiles is generated into the build tree.  Any
       standard UNIX-style make program can build the project through the
       default make target.  A "make install" target is also provided.

  Visual Studio 6
       Generates Visual Studio 6 project files.


  Visual Studio 7
       Generates Visual Studio .NET 2002 project files.


  Visual Studio 7 .NET 2003
       Generates Visual Studio .NET 2003 project files.


  Visual Studio 8 2005
       Generates Visual Studio .NET 2005 project files.


  Visual Studio 8 2005 Win64
       Generates Visual Studio .NET 2005 Win64 project files.


  Watcom WMake
       Generates Watcom WMake makefiles.


------------------------------------------------------------------------------
Listfile Commands

The following commands are available in CMakeLists.txt code:

  ADD_CUSTOM_COMMAND
       Add a custom build rule to the generated build system.

       There are two main signatures for ADD_CUSTOM_COMMAND The first
       signature is for adding a custom command to produce an output.

         ADD_CUSTOM_COMMAND(OUTPUT output1 [output2 ...]
                            COMMAND command1 [ARGS] [args1...]
                            [COMMAND command2 [ARGS] [args2...] ...]
                            [MAIN_DEPENDENCY depend]
                            [DEPENDS [depends...]]
                            [WORKING_DIRECTORY dir]
                            [COMMENT comment] [VERBATIM] [APPEND])

       This defines a new command that can be executed during the build
       process.  The outputs named should be listed as source files in the
       target for which they are to be generated.  Note that MAIN_DEPENDENCY
       is completely optional and is used as a suggestion to visual studio
       about where to hang the custom command.  In makefile terms this
       creates a new target in the following form:

         OUTPUT: MAIN_DEPENDENCY DEPENDS
                 COMMAND

       If more than one command is specified they will be executed in order.
       The optional ARGS argument is for backward compatibility and will be
       ignored.

       The second signature adds a custom command to a target such as a
       library or executable.  This is useful for performing an operation
       before or after building the target:

         ADD_CUSTOM_COMMAND(TARGET target
                            PRE_BUILD | PRE_LINK | POST_BUILD
                            COMMAND command1 [ARGS] [args1...]
                            [COMMAND command2 [ARGS] [args2...] ...]
                            [WORKING_DIRECTORY dir]
                            [COMMENT comment] [VERBATIM])

       This defines a new command that will be associated with building the
       specified target.  When the command will happen is determined by which
       of the following is specified:

         PRE_BUILD - run before all other dependencies
         PRE_LINK - run after other dependencies
         POST_BUILD - run after the target has been built

       Note that the PRE_BUILD option is only supported on Visual Studio 7 or
       later.  For all other generators PRE_BUILD will be treated as
       PRE_LINK.

       If WORKING_DIRECTORY is specified the command will be executed in the
       directory given.  If COMMENT is set, the value will be displayed as a
       message before the commands are executed at build time.  If APPEND is
       specified the COMMAND and DEPENDS option values are appended to the
       custom command for the first output specified.  There must have
       already been a previous call to this command with the same output.
       The COMMENT, WORKING_DIRECTORY, and MAIN_DEPENDENCY options are
       currently ignored when APPEND is given, but may be used in the future.

       If VERBATIM is given then all the arguments to the commands will be
       passed exactly as specified no matter the build tool used.  Note that
       one level of escapes is still used by the CMake language processor
       before ADD_CUSTOM_TARGET even sees the arguments.  Use of VERBATIM is
       recommended as it enables correct behavior.  When VERBATIM is not
       given the behavior is platform specific.  In the future VERBATIM may
       be enabled by default.  The only reason it is an option is to preserve
       compatibility with older CMake code.

       If the output of the custom command is not actually created as a file
       on disk it should be marked as SYMBOLIC with
       SET_SOURCE_FILES_PROPERTIES.

  ADD_CUSTOM_TARGET
       Add a target with no output so it will always be built.

         ADD_CUSTOM_TARGET(Name [ALL] [command1 [args1...]]
                           [COMMAND command2 [args2...] ...]
                           [DEPENDS depend depend depend ... ]
                           [WORKING_DIRECTORY dir]
                           [COMMENT comment] [VERBATIM])

       Adds a target with the given name that executes the given commands.
       The target has no output file and is ALWAYS CONSIDERED OUT OF DATE
       even if the commands try to create a file with the name of the target.
       Use ADD_CUSTOM_COMMAND to generate a file with dependencies.  By
       default nothing depends on the custom target.  Use ADD_DEPENDENCIES to
       add dependencies to or from other targets.  If the ALL option is
       specified it indicates that this target should be added to the default
       build target so that it will be run every time (the command cannot be
       called ALL).  The command and arguments are optional and if not
       specified an empty target will be created.  If WORKING_DIRECTORY is
       set, then the command will be run in that directory.  If COMMENT is
       set, the value will be displayed as a message before the commands are
       executed at build time.  Dependencies listed with the DEPENDS argument
       may reference files and outputs of custom commands created with
       ADD_CUSTOM_COMMAND.

       If VERBATIM is given then all the arguments to the commands will be
       passed exactly as specified no matter the build tool used.  Note that
       one level of escapes is still used by the CMake language processor
       before ADD_CUSTOM_TARGET even sees the arguments.  Use of VERBATIM is
       recommended as it enables correct behavior.  When VERBATIM is not
       given the behavior is platform specific.  In the future VERBATIM may
       be enabled by default.  The only reason it is an option is to preserve
       compatibility with older CMake code.

  ADD_DEFINITIONS
       Adds -D define flags to the command line of C and C++ compilers.

         ADD_DEFINITIONS(-DFOO -DBAR ...)

       Adds flags to command line of C and C++ compilers.  This command can
       be used to add any flag to a compile line, but the -D flag is accepted
       most C/C++ compilers.  Other flags may not be as portable.

  ADD_DEPENDENCIES
       Add a dependency between top-level targets.

         ADD_DEPENDENCIES(target-name depend-target1
                          depend-target2 ...)

       Make a top-level target depend on other top-level targets.  A
       top-level target is one created by ADD_EXECUTABLE, ADD_LIBRARY, or
       ADD_CUSTOM_TARGET.  Adding dependencies with this command can be used
       to make sure one target is built before another target.  See the
       DEPENDS option of ADD_CUSTOM_TARGET and ADD_CUSTOM_COMMAND for adding
       file-level dependencies in custom rules.  See the OBJECT_DEPENDS
       option in SET_SOURCE_FILES_PROPERTIES to add file-level dependencies
       to object files.

  ADD_EXECUTABLE
       Add an executable to the project using the specified source files.

         ADD_EXECUTABLE(exename [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL]
                        source1 source2 ... sourceN)

       This command adds an executable target to the current directory.  The
       executable will be built from the list of source files specified.

       After specifying the executable name, WIN32 and/or MACOSX_BUNDLE can
       be specified.  WIN32 indicates that the executable (when compiled on
       windows) is a windows app (using WinMain) not a console app (using
       main).  The variable CMAKE_MFC_FLAG be used if the windows app uses
       MFC.  This variable can be set to the following values:

        0: Use Standard Windows Libraries
        1: Use MFC in a Static Library 
        2: Use MFC in a Shared DLL 

       MACOSX_BUNDLE indicates that when build on Mac OSX, executable should
       be in the bundle form.  The MACOSX_BUNDLE also allows several
       variables to be specified:

         MACOSX_BUNDLE_INFO_STRING
         MACOSX_BUNDLE_ICON_FILE
         MACOSX_BUNDLE_GUI_IDENTIFIER
         MACOSX_BUNDLE_LONG_VERSION_STRING
         MACOSX_BUNDLE_BUNDLE_NAME
         MACOSX_BUNDLE_SHORT_VERSION_STRING
         MACOSX_BUNDLE_BUNDLE_VERSION
         MACOSX_BUNDLE_COPYRIGHT

       If EXCLUDE_FROM_ALL is given the target will not be built by default.
       It will be built only if the user explicitly builds the target or
       another target that requires the target depends on it.

  ADD_LIBRARY
       Add a library to the project using the specified source files.

         ADD_LIBRARY(libname [SHARED | STATIC | MODULE] [EXCLUDE_FROM_ALL]
                     source1 source2 ... sourceN)

       Adds a library target.  SHARED, STATIC or MODULE keywords are used to
       set the library type.  If the keyword MODULE appears, the library type
       is set to MH_BUNDLE on systems which use dyld.  On systems without
       dyld, MODULE is treated like SHARED.  If no keywords appear as the
       second argument, the type defaults to the current value of
       BUILD_SHARED_LIBS.  If this variable is not set, the type defaults to
       STATIC.

       If EXCLUDE_FROM_ALL is given the target will not be built by default.
       It will be built only if the user explicitly builds the target or
       another target that requires the target depends on it.

  ADD_SUBDIRECTORY
       Add a subdirectory to the build.

         ADD_SUBDIRECTORY(source_dir [binary_dir] 
                          [EXCLUDE_FROM_ALL])

       Add a subdirectory to the build.  The source_dir specifies the
       directory in which the source CmakeLists.txt and code files are
       located.  If it is a relative path it will be evaluated with respect
       to the current directory (the typical usage), but it may also be an
       absolute path.  The binary_dir specifies the directory in which to
       place the output files.  If it is a relative path it will be evaluated
       with respect to the current output directory, but it may also be an
       absolute path.  If binary_dir is not specified, the value of
       source_dir, before expanding any relative path, will be used (the
       typical usage).  The CMakeLists.txt file in the specified source
       directory will be processed immediately by CMake before processing in
       the current input file continues beyond this command.

       If the EXCLUDE_FROM_ALL argument is provided then this subdirectory
       will not be included in build by default.  Users will have to
       explicitly start a build in the generated output directory.  This is
       useful for having cmake create a build system for a set of examples in
       a project.  One would want cmake to generate a single build system for
       all the examples, but one may not want the targets to show up in the
       main build system.

  ADD_TEST
       Add a test to the project with the specified arguments.

         ADD_TEST(testname Exename arg1 arg2 ...)

       If the ENABLE_TESTING command has been run, this command adds a test
       target to the current directory.  If ENABLE_TESTING has not been run,
       this command does nothing.  The tests are run by the testing subsystem
       by executing Exename with the specified arguments.  Exename can be
       either an executable built by this project or an arbitrary executable
       on the system (like tclsh).  The test will be run with the current
       working directory set to the CMakeList.txt files corresponding
       directory in the binary tree.

  AUX_SOURCE_DIRECTORY
       Find all source files in a directory.

         AUX_SOURCE_DIRECTORY(dir VARIABLE)

       Collects the names of all the source files in the specified directory
       and stores the list in the variable provided.  This command is
       intended to be used by projects that use explicit template
       instantiation.  Template instantiation files can be stored in a
       "Templates" subdirectory and collected automatically using this
       command to avoid manually listing all instantiations.

       It is tempting to use this command to avoid writing the list of source
       files for a library or executable target.  While this seems to work,
       there is no way for CMake to generate a build system that knows when a
       new source file has been added.  Normally the generated build system
       knows when it needs to rerun CMake because the CMakeLists.txt file is
       modified to add a new source.  When the source is just added to the
       directory without modifying this file, one would have to manually
       rerun CMake to generate a build system incorporating the new file.

  BUILD_COMMAND
       Get the command line that will build this project.

         BUILD_COMMAND(variable MAKECOMMAND)

       Sets the given variable to a string containing the command that will
       build this project from the root of the build tree using the build
       tool given by MAKECOMMAND.  MAKECOMMAND should be msdev, nmake, make
       or one of the end user build tools.  This is useful for configuring
       testing systems.

  BUILD_NAME
       Deprecated.  Use ${CMAKE_SYSTEM} and ${CMAKE_CXX_COMPILER} instead.

         BUILD_NAME(variable)

       Sets the specified variable to a string representing the platform and
       compiler settings.  These values are now available through the
       CMAKE_SYSTEM and CMAKE_CXX_COMPILER variables.

  CMAKE_MINIMUM_REQUIRED
       Set the minimum required version of cmake for a project.

         CMAKE_MINIMUM_REQUIRED(VERSION versionNumber [FATAL_ERROR])

       Let cmake know that the project requires a certain version of a cmake,
       or newer.  CMake will also try to be backwards compatible to the
       version of cmake specified, if a newer version of cmake is running.
       If FATAL_ERROR is given then failure to meet the requirements will be
       considered an error instead of a warning.

  CONFIGURE_FILE
       Copy a file to another location and modify its contents.

         CONFIGURE_FILE(InputFile OutputFile
                        [COPYONLY] [ESCAPE_QUOTES] [@ONLY])

       The Input and Ouput files have to have full paths.  This command
       replaces any variables in the input file referenced as ${VAR} or @VAR@
       with their values as determined by CMake.  If a variable is not
       defined, it will be replaced with nothing.  If COPYONLY is specified,
       then no variable expansion will take place.  If ESCAPE_QUOTES is
       specified then any substituted quotes will be C-style escaped.  The
       file will be configured with the current values of CMake variables.
       If @ONLY is specified, only variables of the form @VAR@ will be
       replaces and ${VAR} will be ignored.  This is useful for configuring
       scripts that use ${VAR}.  Any occurrences of #cmakedefine VAR will be
       replaced with either #define VAR or /* #undef VAR */ depending on the
       setting of VAR in CMake

  CREATE_TEST_SOURCELIST
       Create a test driver and source list for building test programs.

         CREATE_TEST_SOURCELIST(SourceListName DriverName
                                test1 test2 test3
                                EXTRA_INCLUDE include.h
                                FUNCTION function)

       A test driver is a program that links together many small tests into a
       single executable.  This is useful when building static executables
       with large libraries to shrink the total required size.  The list of
       source files needed to build the test driver will be in
       SourceListName.  DriverName is the name of the test driver program.
       The rest of the arguments consist of a list of test source files, can
       be semicolon separated.  Each test source file should have a function
       in it that is the same name as the file with no extension (foo.cxx
       should have int foo();) DriverName will be able to call each of the
       tests by name on the command line.  If EXTRA_INCLUDE is specified,
       then the next argument is included into the generated file.  If
       FUNCTION is specified, then the next argument is taken as a function
       name that is passed a pointer to ac and av.  This can be used to add
       extra command line processing to each test.  The cmake variable
       CMAKE_TESTDRIVER_BEFORE_TESTMAIN can be set to have code that will be
       placed directly before calling the test main function.
       CMAKE_TESTDRIVER_AFTER_TESTMAIN can be set to have code that will be
       placed directly after the call to the test main function.

  ELSE
       Starts the ELSE portion of an IF block.

         ELSE(expression)

       See the IF command.

  ELSEIF
       Starts the ELSEIF portion of an IF block.

         ELSEIF(expression)

       See the IF command.

  ENABLE_LANGUAGE
       Set a name for the entire project.

         ENABLE_LANGUAGE(languageName)

       This command enables support for the named language in CMake.

  ENABLE_TESTING
       Enable testing for current directory and below.

         ENABLE_TESTING()

       Enables testing for this directory and below.  See also the ADD_TEST
       command.  Note that ctest expects to find a test file in the build
       directory root.  Therefore, this command should be in the source
       directory root.

  ENDFOREACH
       Ends a list of commands in a FOREACH block.

         ENDFOREACH(expression)

       See the FOREACH command.

  ENDIF
       Ends a list of commands in an IF block.

         ENDIF(expression)

       See the IF command.

  ENDMACRO
       Ends a list of commands in a MACRO block.

         ENDMACRO(expression)

       See the MACRO command.

  ENDWHILE
       Ends a list of commands in a WHILE block.

         ENDWHILE(expression)

       See the WHILE command.

  EXEC_PROGRAM
       Run and executable program during the processing of the CMakeList.txt
       file.

         EXEC_PROGRAM(Executable [directory in which to run]
                      [ARGS <arguments to executable>]
                      [OUTPUT_VARIABLE <var>]
                      [RETURN_VALUE <var>])

       The executable is run in the optionally specified directory.  The
       executable can include arguments if it is double quoted, but it is
       better to use the optional ARGS argument to specify arguments to the
       program.  This is because cmake will then be able to escape spaces in
       the executable path.  An optional argument OUTPUT_VARIABLE specifies a
       variable in which to store the output.  To capture the return value of
       the execution, provide a RETURN_VALUE.  If OUTPUT_VARIABLE is
       specified, then no output will go to the stdout/stderr of the console
       running cmake.

       The EXECUTE_PROCESS command is a newer more powerful version of
       EXEC_PROGRAM, but the old command has been kept for compatibility.

  EXECUTE_PROCESS
       Execute one or more child processes.

         EXECUTE_PROCESS(COMMAND <cmd1> [args1...]]
                         [COMMAND <cmd2> [args2...] [...]]
                         [WORKING_DIRECTORY <directory>]
                         [TIMEOUT <seconds>]
                         [RESULT_VARIABLE <variable>]
                         [OUTPUT_VARIABLE <variable>]
                         [ERROR_VARIABLE <variable>]
                         [INPUT_FILE <file>]
                         [OUTPUT_FILE <file>]
                         [ERROR_FILE <file>]
                         [OUTPUT_QUIET]
                         [ERROR_QUIET]
                         [OUTPUT_STRIP_TRAILING_WHITESPACE]
                         [ERROR_STRIP_TRAILING_WHITESPACE])

       Runs the given sequence of one or more commands with the standard
       output of each process piped to the standard input of the next.  A
       single standard error pipe is used for all processes.  If
       WORKING_DIRECTORY is given the named directory will be set as the
       current working directory of the child processes.  If TIMEOUT is given
       the child processes will be terminated if they do not finish in the
       specified number of seconds (fractions are allowed).  If
       RESULT_VARIABLE is given the variable will be set to contain the
       result of running the processes.  This will be an integer return code
       from the last child or a string describing an error condition.  If
       OUTPUT_VARIABLE or ERROR_VARIABLE are given the variable named will be
       set with the contents of the standard output and standard error pipes
       respectively.  If the same variable is named for both pipes their
       output will be merged in the order produced.  If INPUT_FILE,
       OUTPUT_FILE, or ERROR_FILE is given the file named will be attached to
       the standard input of the first process, standard output of the last
       process, or standard error of all processes respectively.  If
       OUTPUT_QUIET or ERROR_QUIET is given then the standard output or
       standard error results will be quietly ignored.  If more than one
       OUTPUT_* or ERROR_* option is given for the same pipe the precedence
       is not specified.  If no OUTPUT_* or ERROR_* options are given the
       output will be shared with the corresponding pipes of the CMake
       process itself.

       The EXECUTE_PROCESS command is a newer more powerful version of
       EXEC_PROGRAM, but the old command has been kept for compatibility.

  EXPORT_LIBRARY_DEPENDENCIES
       Write out the dependency information for all targets of a project.

         EXPORT_LIBRARY_DEPENDENCIES(FILE [APPEND])

       Create a file that can be included into a CMake listfile with the
       INCLUDE command.  The file will contain a number of SET commands that
       will set all the variables needed for library dependency information.
       This should be the last command in the top level CMakeLists.txt file
       of the project.  If the APPEND option is specified, the SET commands
       will be appended to the given file instead of replacing it.

  FILE
       File manipulation command.

         FILE(WRITE filename "message to write"... )
         FILE(APPEND filename "message to write"... )
         FILE(READ filename variable)
         FILE(GLOB variable [RELATIVE path] [globbing expressions]...)
         FILE(GLOB_RECURSE variable [RELATIVE path] 
              [globbing expressions]...)
         FILE(REMOVE [directory]...)
         FILE(REMOVE_RECURSE [directory]...)
         FILE(MAKE_DIRECTORY [directory]...)
         FILE(RELATIVE_PATH variable directory file)
         FILE(TO_CMAKE_PATH path result)
         FILE(TO_NATIVE_PATH path result)

       WRITE will write a message into a file called 'filename'.  It
       overwrites the file if it already exists, and creates the file if it
       does not exist.

       APPEND will write a message into a file same as WRITE, except it will
       append it to the end of the file

       NOTE: When using FILE WRITE and FILE APPEND, the produced file cannot
       be used as an input to CMake (CONFIGURE_FILE, source file ...) because
       it will lead to an infinite loop.  Use CONFIGURE_FILE if you want to
       generate input files to CMake.

       READ will read the content of a file and store it into the variable.

       GLOB will generate a list of all files that match the globbing
       expressions and store it into the variable.  Globbing expressions are
       similar to regular expressions, but much simpler.  If RELATIVE flag is
       specified for an expression, the results will be returned as a
       relative path to the given path.

       Examples of globbing expressions include:

          *.cxx      - match all files with extension cxx
          *.vt?      - match all files with extension vta,...,vtz
          f[3-5].txt - match files f3.txt, f4.txt, f5.txt

       GLOB_RECURSE will generate similar list as the regular GLOB, except it
       will traverse all the subdirectories of the matched directory and
       match the files.

       Examples of recursive globbing include:

          /dir/*.py  - match all python files in /dir and subdirectories

       MAKE_DIRECTORY will create a directory at the specified location

       RELATIVE_PATH will determine relative path from directory to the given
       file.

       TO_CMAKE_PATH will convert path into a cmake sytle path with unix /.
       The input can be a single path or a system path like "$ENV{PATH}".
       Note the double quotes around the ENV call TO_CMAKE_PATH only takes
       one argument.

       TO_NATIVE_PATH works just like TO_CMAKE_PATH, but will convert from a
       cmake style path into the native path style \ for windows and / for
       UNIX.

  FIND_FILE
       Find the full path to a file.

          FIND_FILE(<VAR> name1 path1 path2 ...)

       This is the short-hand signature for the command that is sufficient in
       many cases.  It is the same as FIND_FILE(<VAR> name1 PATHS path2 path2
       ...)

          FIND_FILE(
                    <VAR> 
                    name | NAMES name1 [name2 ...]
                    PATHS path1 [path2 ... ENV var]
                    [PATH_SUFFIXES suffix1 [suffix2 ...]]
                    [DOC "cache documentation string"]
                    [NO_DEFAULT_PATH]
                    [NO_CMAKE_ENVIRONMENT_PATH]
                    [NO_CMAKE_PATH]
                    [NO_SYSTEM_ENVIRONMENT_PATH]
                    [NO_CMAKE_SYSTEM_PATH]
                   )

       This command is used to find a full path to named file.  A cache entry
       named by <VAR> is created to store the result of this command.  If the
       full path to a file is found the result is stored in the variable and
       the search will not be repeated unless the variable is cleared.  If
       nothing is found, the result will be <VAR>-NOTFOUND, and the search
       will be attempted again the next time FIND_FILE is invoked with the
       same variable.  The name of the full path to a file that is searched
       for is specified by the names listed after the NAMES argument.
       Additional search locations can be specified after the PATHS argument.
       If ENV var is found in the PATHS section the environment variable var
       will be read and converted from a system environment variable to a
       cmake style list of paths.  For example ENV PATH would be a way to
       list the system path variable.  The argument after DOC will be used
       for the documentation string in the cache.  PATH_SUFFIXES can be used
       to give sub directories that will be appended to the search paths.

       If NO_DEFAULT_PATH is specified, then no additional paths are added to
       the search.  If NO_DEFAULT_PATH is not specified, the search process
       is as follows:

       1.  Search cmake specific environment variables.  This can be skipped
       if NO_CMAKE_ENVIRONMENT_PATH is passed.

          CMAKE_FRAMEWORK_PATH
          CMAKE_APPBUNDLE_PATH
          CMAKE_INCLUDE_PATH

       2.  Search cmake variables with the same names as the cmake specific
       environment variables.  These are intended to be used on the command
       line with a -DVAR=value.  This can be skipped if NO_CMAKE_PATH is
       passed.

          CMAKE_FRAMEWORK_PATH
          CMAKE_APPBUNDLE_PATH
          CMAKE_INCLUDE_PATH

       3.  Search the standard system environment variables.  This can be
       skipped if NO_SYSTEM_ENVIRONMENT_PATH is an argument.

          PATH
          INCLUDE

       4.  Search cmake variables defined in the Platform files for the
       current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is
       passed.

          CMAKE_SYSTEM_FRAMEWORK_PATH
          CMAKE_SYSTEM_APPBUNDLE_PATH
          CMAKE_SYSTEM_INCLUDE_PATH

       5.  Search the paths specified after PATHS or in the short-hand
       version of the command.

       On Darwin or systems supporting OSX Frameworks, the cmake variable
       CMAKE_FIND_FRAMEWORK can be set to empty or one of the following:

          "FIRST"  - Try to find frameworks before standard
                     libraries or headers. This is the default on Darwin.
          "LAST"   - Try to find frameworks after standard
                     libraries or headers.
          "ONLY"   - Only try to find frameworks.
          "NEVER". - Never try to find frameworks.

       On Darwin or systems supporting OSX Application Bundles, the cmake
       variable CMAKE_FIND_APPBUNDLE can be set to empty or one of the
       following:

          "FIRST"  - Try to find application bundles before standard
                     programs. This is the default on Darwin.
          "LAST"   - Try to find application bundles after standard
                     programs.
          "ONLY"   - Only try to find application bundles.
          "NEVER". - Never try to find application bundles.

       The reason the paths listed in the call to the command are searched
       last is that most users of CMake would expect things to be found first
       in the locations specified by their environment.  Projects may
       override this behavior by simply calling the command twice:

          FIND_FILE(<VAR> NAMES name PATHS paths NO_DEFAULT_PATH)
          FIND_FILE(<VAR> NAMES name)

       Once one of these calls succeeds the result variable will be set and
       stored in the cache so that neither call will search again.

  FIND_LIBRARY
       Find a library.

          FIND_LIBRARY(<VAR> name1 path1 path2 ...)

       This is the short-hand signature for the command that is sufficient in
       many cases.  It is the same as FIND_LIBRARY(<VAR> name1 PATHS path2
       path2 ...)

          FIND_LIBRARY(
                    <VAR> 
                    name | NAMES name1 [name2 ...]
                    PATHS path1 [path2 ... ENV var]
                    [PATH_SUFFIXES suffix1 [suffix2 ...]]
                    [DOC "cache documentation string"]
                    [NO_DEFAULT_PATH]
                    [NO_CMAKE_ENVIRONMENT_PATH]
                    [NO_CMAKE_PATH]
                    [NO_SYSTEM_ENVIRONMENT_PATH]
                    [NO_CMAKE_SYSTEM_PATH]
                   )

       This command is used to find a library.  A cache entry named by <VAR>
       is created to store the result of this command.  If the library is
       found the result is stored in the variable and the search will not be
       repeated unless the variable is cleared.  If nothing is found, the
       result will be <VAR>-NOTFOUND, and the search will be attempted again
       the next time FIND_LIBRARY is invoked with the same variable.  The
       name of the library that is searched for is specified by the names
       listed after the NAMES argument.  Additional search locations can be
       specified after the PATHS argument.  If ENV var is found in the PATHS
       section the environment variable var will be read and converted from a
       system environment variable to a cmake style list of paths.  For
       example ENV PATH would be a way to list the system path variable.  The
       argument after DOC will be used for the documentation string in the
       cache.  PATH_SUFFIXES can be used to give sub directories that will be
       appended to the search paths.

       If NO_DEFAULT_PATH is specified, then no additional paths are added to
       the search.  If NO_DEFAULT_PATH is not specified, the search process
       is as follows:

       1.  Search cmake specific environment variables.  This can be skipped
       if NO_CMAKE_ENVIRONMENT_PATH is passed.

          CMAKE_FRAMEWORK_PATH
          CMAKE_APPBUNDLE_PATH
          CMAKE_LIBRARY_PATH

       2.  Search cmake variables with the same names as the cmake specific
       environment variables.  These are intended to be used on the command
       line with a -DVAR=value.  This can be skipped if NO_CMAKE_PATH is
       passed.

          CMAKE_FRAMEWORK_PATH
          CMAKE_APPBUNDLE_PATH
          CMAKE_LIBRARY_PATH

       3.  Search the standard system environment variables.  This can be
       skipped if NO_SYSTEM_ENVIRONMENT_PATH is an argument.

          PATH
          LIB

       4.  Search cmake variables defined in the Platform files for the
       current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is
       passed.

          CMAKE_SYSTEM_FRAMEWORK_PATH
          CMAKE_SYSTEM_APPBUNDLE_PATH
          CMAKE_SYSTEM_LIBRARY_PATH

       5.  Search the paths specified after PATHS or in the short-hand
       version of the command.

       On Darwin or systems supporting OSX Frameworks, the cmake variable
       CMAKE_FIND_FRAMEWORK can be set to empty or one of the following:

          "FIRST"  - Try to find frameworks before standard
                     libraries or headers. This is the default on Darwin.
          "LAST"   - Try to find frameworks after standard
                     libraries or headers.
          "ONLY"   - Only try to find frameworks.
          "NEVER". - Never try to find frameworks.

       On Darwin or systems supporting OSX Application Bundles, the cmake
       variable CMAKE_FIND_APPBUNDLE can be set to empty or one of the
       following:

          "FIRST"  - Try to find application bundles before standard
                     programs. This is the default on Darwin.
          "LAST"   - Try to find application bundles after standard
                     programs.
          "ONLY"   - Only try to find application bundles.
          "NEVER". - Never try to find application bundles.

       The reason the paths listed in the call to the command are searched
       last is that most users of CMake would expect things to be found first
       in the locations specified by their environment.  Projects may
       override this behavior by simply calling the command twice:

          FIND_LIBRARY(<VAR> NAMES name PATHS paths NO_DEFAULT_PATH)
          FIND_LIBRARY(<VAR> NAMES name)

       Once one of these calls succeeds the result variable will be set and
       stored in the cache so that neither call will search again.

       If the library found is a framework, then VAR will be set to the full
       path to the framework <fullPath>/A.framework.  When a full path to a
       framework is used as a library, CMake will use a -framework A, and a
       -F<fullPath> to link the framework to the target.

  FIND_PACKAGE
       Load settings for an external project.

         FIND_PACKAGE(<name> [major.minor] [QUIET] [NO_MODULE]
                      [[REQUIRED|COMPONENTS] [componets...]])

       Finds and loads settings from an external project.  <name>_FOUND will
       be set to indicate whether the package was found.  Settings that can
       be used when <name>_FOUND is true are package-specific.  The package
       is found through several steps.  Directories listed in
       CMAKE_MODULE_PATH are searched for files called "Find<name>.cmake".
       If such a file is found, it is read and processed by CMake, and is
       responsible for finding the package.  This first step may be skipped
       by using the NO_MODULE option.  If no such file is found, it is
       expected that the package is another project built by CMake that has a
       "<name>Config.cmake" file.  A cache entry called <name>_DIR is created
       and is expected to be set to the directory containing this file.  If
       the file is found, it is read and processed by CMake to load the
       settings of the package.  If <name>_DIR has not been set during a
       configure step, the command will generate an error describing the
       problem unless the QUIET argument is specified.  If <name>_DIR has
       been set to a directory not containing a "<name>Config.cmake" file, an
       error is always generated.  If REQUIRED is specified and the package
       is not found, a FATAL_ERROR is generated and the configure step stops
       executing.  A package-specific list of components may be listed after
       the REQUIRED option, or after the COMPONENTS option if no REQUIRED
       option is given.

  FIND_PATH
       Find the directory containing a file.

          FIND_PATH(<VAR> name1 path1 path2 ...)

       This is the short-hand signature for the command that is sufficient in
       many cases.  It is the same as FIND_PATH(<VAR> name1 PATHS path2 path2
       ...)

          FIND_PATH(
                    <VAR> 
                    name | NAMES name1 [name2 ...]
                    PATHS path1 [path2 ... ENV var]
                    [PATH_SUFFIXES suffix1 [suffix2 ...]]
                    [DOC "cache documentation string"]
                    [NO_DEFAULT_PATH]
                    [NO_CMAKE_ENVIRONMENT_PATH]
                    [NO_CMAKE_PATH]
                    [NO_SYSTEM_ENVIRONMENT_PATH]
                    [NO_CMAKE_SYSTEM_PATH]
                   )

       This command is used to find a directory containing the named file.  A
       cache entry named by <VAR> is created to store the result of this
       command.  If the file in a directory is found the result is stored in
       the variable and the search will not be repeated unless the variable
       is cleared.  If nothing is found, the result will be <VAR>-NOTFOUND,
       and the search will be attempted again the next time FIND_PATH is
       invoked with the same variable.  The name of the file in a directory
       that is searched for is specified by the names listed after the NAMES
       argument.  Additional search locations can be specified after the
       PATHS argument.  If ENV var is found in the PATHS section the
       environment variable var will be read and converted from a system
       environment variable to a cmake style list of paths.  For example ENV
       PATH would be a way to list the system path variable.  The argument
       after DOC will be used for the documentation string in the cache.
       PATH_SUFFIXES can be used to give sub directories that will be
       appended to the search paths.

       If NO_DEFAULT_PATH is specified, then no additional paths are added to
       the search.  If NO_DEFAULT_PATH is not specified, the search process
       is as follows:

       1.  Search cmake specific environment variables.  This can be skipped
       if NO_CMAKE_ENVIRONMENT_PATH is passed.

          CMAKE_FRAMEWORK_PATH
          CMAKE_APPBUNDLE_PATH
          CMAKE_INCLUDE_PATH

       2.  Search cmake variables with the same names as the cmake specific
       environment variables.  These are intended to be used on the command
       line with a -DVAR=value.  This can be skipped if NO_CMAKE_PATH is
       passed.

          CMAKE_FRAMEWORK_PATH
          CMAKE_APPBUNDLE_PATH
          CMAKE_INCLUDE_PATH

       3.  Search the standard system environment variables.  This can be
       skipped if NO_SYSTEM_ENVIRONMENT_PATH is an argument.

          PATH
          INCLUDE

       4.  Search cmake variables defined in the Platform files for the
       current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is
       passed.

          CMAKE_SYSTEM_FRAMEWORK_PATH
          CMAKE_SYSTEM_APPBUNDLE_PATH
          CMAKE_SYSTEM_INCLUDE_PATH

       5.  Search the paths specified after PATHS or in the short-hand
       version of the command.

       On Darwin or systems supporting OSX Frameworks, the cmake variable
       CMAKE_FIND_FRAMEWORK can be set to empty or one of the following:

          "FIRST"  - Try to find frameworks before standard
                     libraries or headers. This is the default on Darwin.
          "LAST"   - Try to find frameworks after standard
                     libraries or headers.
          "ONLY"   - Only try to find frameworks.
          "NEVER". - Never try to find frameworks.

       On Darwin or systems supporting OSX Application Bundles, the cmake
       variable CMAKE_FIND_APPBUNDLE can be set to empty or one of the
       following:

          "FIRST"  - Try to find application bundles before standard
                     programs. This is the default on Darwin.
          "LAST"   - Try to find application bundles after standard
                     programs.
          "ONLY"   - Only try to find application bundles.
          "NEVER". - Never try to find application bundles.

       The reason the paths listed in the call to the command are searched
       last is that most users of CMake would expect things to be found first
       in the locations specified by their environment.  Projects may
       override this behavior by simply calling the command twice:

          FIND_PATH(<VAR> NAMES name PATHS paths NO_DEFAULT_PATH)
          FIND_PATH(<VAR> NAMES name)

       Once one of these calls succeeds the result variable will be set and
       stored in the cache so that neither call will search again.

       When searching for frameworks, if the file is specified as A/b.h, then
       the framework search will look for A.framework/Headers/b.h.  If that
       is found the path will be set to the path to the framework.  CMake
       will convert this to the correct -F option to include the file.

  FIND_PROGRAM
       Find an executable program.

          FIND_PROGRAM(<VAR> name1 path1 path2 ...)

       This is the short-hand signature for the command that is sufficient in
       many cases.  It is the same as FIND_PROGRAM(<VAR> name1 PATHS path2
       path2 ...)

          FIND_PROGRAM(
                    <VAR> 
                    name | NAMES name1 [name2 ...]
                    PATHS path1 [path2 ... ENV var]
                    [PATH_SUFFIXES suffix1 [suffix2 ...]]
                    [DOC "cache documentation string"]
                    [NO_DEFAULT_PATH]
                    [NO_CMAKE_ENVIRONMENT_PATH]
                    [NO_CMAKE_PATH]
                    [NO_SYSTEM_ENVIRONMENT_PATH]
                    [NO_CMAKE_SYSTEM_PATH]
                   )

       This command is used to find a program.  A cache entry named by <VAR>
       is created to store the result of this command.  If the program is
       found the result is stored in the variable and the search will not be
       repeated unless the variable is cleared.  If nothing is found, the
       result will be <VAR>-NOTFOUND, and the search will be attempted again
       the next time FIND_PROGRAM is invoked with the same variable.  The
       name of the program that is searched for is specified by the names
       listed after the NAMES argument.  Additional search locations can be
       specified after the PATHS argument.  If ENV var is found in the PATHS
       section the environment variable var will be read and converted from a
       system environment variable to a cmake style list of paths.  For
       example ENV PATH would be a way to list the system path variable.  The
       argument after DOC will be used for the documentation string in the
       cache.  PATH_SUFFIXES can be used to give sub directories that will be
       appended to the search paths.

       If NO_DEFAULT_PATH is specified, then no additional paths are added to
       the search.  If NO_DEFAULT_PATH is not specified, the search process
       is as follows:

       1.  Search cmake specific environment variables.  This can be skipped
       if NO_CMAKE_ENVIRONMENT_PATH is passed.

          CMAKE_FRAMEWORK_PATH
          CMAKE_APPBUNDLE_PATH
          CMAKE_PROGRAM_PATH

       2.  Search cmake variables with the same names as the cmake specific
       environment variables.  These are intended to be used on the command
       line with a -DVAR=value.  This can be skipped if NO_CMAKE_PATH is
       passed.

          CMAKE_FRAMEWORK_PATH
          CMAKE_APPBUNDLE_PATH
          CMAKE_PROGRAM_PATH

       3.  Search the standard system environment variables.  This can be
       skipped if NO_SYSTEM_ENVIRONMENT_PATH is an argument.

          PATH
          

       4.  Search cmake variables defined in the Platform files for the
       current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is
       passed.

          CMAKE_SYSTEM_FRAMEWORK_PATH
          CMAKE_SYSTEM_APPBUNDLE_PATH
          CMAKE_SYSTEM_PROGRAM_PATH

       5.  Search the paths specified after PATHS or in the short-hand
       version of the command.

       On Darwin or systems supporting OSX Frameworks, the cmake variable
       CMAKE_FIND_FRAMEWORK can be set to empty or one of the following:

          "FIRST"  - Try to find frameworks before standard
                     libraries or headers. This is the default on Darwin.
          "LAST"   - Try to find frameworks after standard
                     libraries or headers.
          "ONLY"   - Only try to find frameworks.
          "NEVER". - Never try to find frameworks.

       On Darwin or systems supporting OSX Application Bundles, the cmake
       variable CMAKE_FIND_APPBUNDLE can be set to empty or one of the
       following:

          "FIRST"  - Try to find application bundles before standard
                     programs. This is the default on Darwin.
          "LAST"   - Try to find application bundles after standard
                     programs.
          "ONLY"   - Only try to find application bundles.
          "NEVER". - Never try to find application bundles.

       The reason the paths listed in the call to the command are searched
       last is that most users of CMake would expect things to be found first
       in the locations specified by their environment.  Projects may
       override this behavior by simply calling the command twice:

          FIND_PROGRAM(<VAR> NAMES name PATHS paths NO_DEFAULT_PATH)
          FIND_PROGRAM(<VAR> NAMES name)

       Once one of these calls succeeds the result variable will be set and
       stored in the cache so that neither call will search again.

  FLTK_WRAP_UI
       Create FLTK user interfaces Wrappers.

         FLTK_WRAP_UI(resultingLibraryName source1
                      source2 ... sourceN )

       Produce .h and .cxx files for all the .fl and .fld files listed.  The
       resulting .h and .cxx files will be added to a variable named
       resultingLibraryName_FLTK_UI_SRCS which should be added to your
       library.

  FOREACH
       Evaluate a group of commands for each value in a list.

         FOREACH(loop_var arg1 arg2 ...)
           COMMAND1(ARGS ...)
           COMMAND2(ARGS ...)
           ...
         ENDFOREACH(loop_var)
         FOREACH(loop_var RANGE total)
         FOREACH(loop_var RANGE start stop [step])

       All commands between FOREACH and the matching ENDFOREACH are recorded
       without being invoked.  Once the ENDFOREACH is evaluated, the recorded
       list of commands is invoked once for each argument listed in the
       original FOREACH command.  Before each iteration of the loop
       "${loop_var}" will be set as a variable with the current value in the
       list.

       Foreach can also iterate over a generated range of numbers.  There are
       three types of this iteration:

       * When specifying single number, the range will have elements 0 to
       "total".

       * When specifying two numbers, the range will have elements from the
       first number to the second number.

       * The third optional number is the increment used to iterate from the
       first number to the second number.

  GET_CMAKE_PROPERTY
       Get a property of the CMake instance.

         GET_CMAKE_PROPERTY(VAR property)

       Get a property from the CMake instance.  The value of the property is
       stored in the variable VAR.  If the property is not found, CMake will
       report an error.  Some supported properties include: VARIABLES,
       CACHE_VARIABLES, COMMANDS, and MACROS.

  GET_DIRECTORY_PROPERTY
       Get a property of the directory.

         GET_DIRECTORY_PROPERTY(VAR [DIRECTORY dir] property)

       Get a property from the Directory.  The value of the property is
       stored in the variable VAR.  If the property is not found, CMake will
       report an error.  The properties include: VARIABLES, CACHE_VARIABLES,
       COMMANDS, MACROS, INCLUDE_DIRECTORIES, LINK_DIRECTORIES, DEFINITIONS,
       INCLUDE_REGULAR_EXPRESSION, LISTFILE_STACK, PARENT_DIRECTORY, and
       DEFINITION varname.  If the DIRECTORY argument is provided then the
       property of the provided directory will be retrieved instead of the
       current directory.  You can only get properties of a directory during
       or after it has been traversed by cmake.

  GET_FILENAME_COMPONENT
       Get a specific component of a full filename.

         GET_FILENAME_COMPONENT(VarName FileName
                                PATH|ABSOLUTE|NAME|EXT|NAME_WE
                                [CACHE])

       Set VarName to be the path (PATH), file name (NAME), file extension
       (EXT), file name without extension (NAME_WE) of FileName, or the full
       absolute (ABSOLUTE) file name without symlinks.  Note that the path is
       converted to Unix slashes format and has no trailing slashes.  The
       longest file extension is always considered.  If the optional CACHE
       argument is specified, the result variable is added to the cache.

         GET_FILENAME_COMPONENT(VarName FileName
                                PROGRAM [PROGRAM_ARGS ArgVar]
                                [CACHE])

       The program in FileName will be found in the system search path or
       left as a full path.  If PROGRAM_ARGS is present with PROGRAM, then
       any command-line arguments present in the FileName string are split
       from the program name and stored in ArgVar.  This is used to separate
       a program name from its arguments in a command line string.

  GET_SOURCE_FILE_PROPERTY
       Get a property for a source file.

         GET_SOURCE_FILE_PROPERTY(VAR file property)

       Get a property from a source file.  The value of the property is
       stored in the variable VAR.  If the property is not found, VAR will be
       set to "NOTFOUND".  Use SET_SOURCE_FILES_PROPERTIES to set property
       values.  Source file properties usually control how the file is built.
       One property that is always there is LOCATION

  GET_TARGET_PROPERTY
       Get a property from a target.

         GET_TARGET_PROPERTY(VAR target property)

       Get a property from a target.  The value of the property is stored in
       the variable VAR.  If the property is not found, VAR will be set to
       "NOTFOUND".  Use SET_TARGET_PROPERTIES to set property values.
       Properties are usually used to control how a target is built.

       The read-only property "<CONFIG>_LOCATION" provides the full path to
       the file on disk that will be created for the target when building
       under configuration <CONFIG> (in upper-case, such as
       "DEBUG_LOCATION").  The read-only property "LOCATION" specifies the
       full path to the file on disk that will be created for the target.
       The path may contain a build-system-specific portion that is replaced
       at build time with the configuration getting built (such as
       "$(ConfigurationName)" in VS).  This is very useful for executable
       targets to get the path to the executable file for use in a custom
       command.

       The read-only property "TYPE" returns which type the specified target
       has (EXECUTABLE, STATIC_LIBRARY, SHARED_LIBRARY, MODULE_LIBRARY,
       UTILITY, INSTALL_FILES or INSTALL_PROGRAMS).  This command can get
       properties for any target so far created.  The targets do not need to
       be in the current CMakeLists.txt file.

  GET_TEST_PROPERTY
       Get a property of the test.

         GET_TEST_PROPERTY(test VAR property)

       Get a property from the Test.  The value of the property is stored in
       the variable VAR.  If the property is not found, CMake will report an
       error.

  IF
       Conditionally execute a group of commands.

         IF(expression)
           # THEN section.
           COMMAND1(ARGS ...)
           COMMAND2(ARGS ...)
           ...
         ELSE(expression)
           # ELSE section.
           COMMAND1(ARGS ...)
           COMMAND2(ARGS ...)
           ...
         ENDIF(expression)

       Evaluates the given expression.  If the result is true, the commands
       in the THEN section are invoked.  Otherwise, the commands in the ELSE
       section are invoked.  The ELSE section is optional.  Note that the
       same expression must be given to IF, ELSE, and ENDIF.  Long
       expressions can be used and the order or precedence is that the
       EXISTS, COMMAND, and DEFINED operators will be evaluated first.  Then
       any EQUAL, LESS, GREATER, STRLESS, STRGREATER, STREQUAL, MATCHES will
       be evaluated.  Then NOT operators and finally AND, OR operators will
       be evaluated.  Possible expressions are:

         IF(variable)

       True if the variable's value is not empty, 0, N, NO, OFF, FALSE,
       NOTFOUND, or <variable>-NOTFOUND.

         IF(NOT variable)

       True if the variable's value is empty, 0, N, NO, OFF, FALSE, NOTFOUND,
       or <variable>-NOTFOUND.

         IF(variable1 AND variable2)

       True if both variables would be considered true individually.

         IF(variable1 OR variable2)

       True if either variable would be considered true individually.

         IF(COMMAND command-name)

       True if the given name is a command that can be invoked.

         IF(EXISTS file-name)
         IF(EXISTS directory-name)

       True if the named file or directory exists.  Behavior is well-defined
       only for full paths.

         IF(file1 IS_NEWER_THAN file2)

       True if file1 is newer than file2 or if one of the two files doesn't
       exist.  Behavior is well-defined only for full paths.

         IF(IS_DIRECTORY directory-name)

       True if the given name is a directory.  Behavior is well-defined only
       for full paths.

         IF(variable MATCHES regex)
         IF(string MATCHES regex)

       True if the given string or variable's value matches the given regular
       expression.

         IF(variable LESS number)
         IF(string LESS number)
         IF(variable GREATER number)
         IF(string GREATER number)
         IF(variable EQUAL number)
         IF(string EQUAL number)

       True if the given string or variable's value is a valid number and the
       inequality or equality is true.

         IF(variable STRLESS string)
         IF(string STRLESS string)
         IF(variable STRGREATER string)
         IF(string STRGREATER string)
         IF(variable STREQUAL string)
         IF(string STREQUAL string)

       True if the given string or variable's value is lexicographically less
       (or greater, or equal) than the string on the right.

         IF(DEFINED variable)

       True if the given variable is defined.  It does not matter if the
       variable is true or false just if it has been set.

  INCLUDE
       Read CMake listfile code from the given file.

         INCLUDE(file1 [OPTIONAL])
         INCLUDE(module [OPTIONAL])

       Reads CMake listfile code from the given file.  Commands in the file
       are processed immediately as if they were written in place of the
       INCLUDE command.  If OPTIONAL is present, then no error is raised if
       the file does not exist.

       If a module is specified instead of a file, the file with name
       <modulename>.cmake is searched in the CMAKE_MODULE_PATH.

  INCLUDE_DIRECTORIES
       Add include directories to the build.

         INCLUDE_DIRECTORIES([AFTER|BEFORE] [SYSTEM] dir1 dir2 ...)

       Add the given directories to those searched by the compiler for
       include files.  By default the directories are appended onto the
       current list of directories.  This default behavior can be changed by
       setting CMAKE_INCLUDE_DIRECTORIES_BEFORE to ON.  By using BEFORE or
       AFTER you can select between appending and prepending, independent
       from the default.  If the SYSTEM option is given the compiler will be
       told that the directories are meant as system include directories on
       some platforms.

  INCLUDE_EXTERNAL_MSPROJECT
       Include an external Microsoft project file in a workspace.

         INCLUDE_EXTERNAL_MSPROJECT(projectname location
                                    dep1 dep2 ...)

       Includes an external Microsoft project in the generated workspace
       file.  Currently does nothing on UNIX.

  INCLUDE_REGULAR_EXPRESSION
       Set the regular expression used for dependency checking.

         INCLUDE_REGULAR_EXPRESSION(regex_match [regex_complain])

       Set the regular expressions used in dependency checking.  Only files
       matching regex_match will be traced as dependencies.  Only files
       matching regex_complain will generate warnings if they cannot be found
       (standard header paths are not searched).  The defaults are:

         regex_match    = "^.*$" (match everything)
         regex_complain = "^$" (match empty string only)

  INSTALL
       Specify rules to run at install time.

       This command generates installation rules for a project.  Rules
       specified by calls to this command within a source directory are
       executed in order during installation.  The order across directories
       is not defined.

       There are multiple signatures for this command.  Some of them define
       installation properties for files and targets.  Properties common to
       multiple signatures are covered here but they are valid only for
       signatures that specify them.  DESTINATION arguments specify the
       directory on disk to which a file will be installed.  If a full path
       (with a leading slash or drive letter) is given it is used directly.
       If a relative path is given it is interpreted relative to the value of
       CMAKE_INSTALL_PREFIX.  PERMISSIONS arguments specify permissions for
       installed files.  Valid permissions are OWNER_READ, OWNER_WRITE,
       OWNER_EXECUTE, GROUP_READ, GROUP_WRITE, GROUP_EXECUTE, WORLD_READ,
       WORLD_WRITE, WORLD_EXECUTE, SETUID, and SETGID.  Permissions that do
       not make sense on certain platforms are ignored on those platforms.
       The CONFIGURATIONS argument specifies a list of build configurations
       for which the install rule applies (Debug, Release, etc.).  The
       COMPONENT argument specifies an installation component name with which
       the install rule is associated, such as "runtime" or "development".
       During component-specific installation only install rules associated
       with the given component name will be executed.  During a full
       installation all components are installed.  The RENAME argument
       specifies a name for an installed file that may be different from the
       original file.  Renaming is allowed only when a single file is
       installed by the command.  The OPTIONAL argument specifies that it is
       not an error if the file to be installed does not exist.

       The TARGETS signature:

         INSTALL(TARGETS targets...
                 [[ARCHIVE|LIBRARY|RUNTIME]
                                     [DESTINATION <dir>]
                                     [PERMISSIONS permissions...]
                                     [CONFIGURATIONS [Debug|Release|...]]
                                     [COMPONENT <component>]
                                     [OPTIONAL]
                                    ] [...])

       The TARGETS form specifies rules for installing targets from a
       project.  There are three kinds of target files that may be installed:
       archive, library, and runtime.  Executables are always treated as
       runtime targets.  Static libraries are always treated as archive
       targets.  Module libraries are always treated as library targets.  For
       non-DLL platforms shared libraries are treated as library targets.
       For DLL platforms the DLL part of a shared library is treated as a
       runtime target and the corresponding import library is treated as an
       archive target.  All Windows-based systems including Cygwin are DLL
       platforms.  The ARCHIVE, LIBRARY, and RUNTIME arguments change the
       type of target to which the subsequent properties apply.  If none is
       given the installation properties apply to all target types.  If only
       one is given then only targets of that type will be installed (which
       can be used to install just a DLL or just an import library).

       One or more groups of properties may be specified in a single call to
       the TARGETS form of this command.  A target may be installed more than
       once to different locations.  Consider hypothetical targets "myExe",
       "mySharedLib", and "myStaticLib".  The code

           INSTALL(TARGETS myExe mySharedLib myStaticLib
                   RUNTIME DESTINATION bin
                   LIBRARY DESTINATION lib
                   ARCHIVE DESTINATION lib/static)
           INSTALL(TARGETS mySharedLib DESTINATION /some/full/path)

       will install myExe to <prefix>/bin and myStaticLib to
       <prefix>/lib/static.  On non-DLL platforms mySharedLib will be
       installed to <prefix>/lib and /some/full/path.  On DLL platforms the
       mySharedLib DLL will be installed to <prefix>/bin and /some/full/path
       and its import library will be installed to <prefix>/lib/static and
       /some/full/path.  On non-DLL platforms mySharedLib will be installed
       to <prefix>/lib and /some/full/path.

       The FILES signature:

         INSTALL(FILES files... DESTINATION <dir>
                 [PERMISSIONS permissions...]
                 [CONFIGURATIONS [Debug|Release|...]]
                 [COMPONENT <component>]
                 [RENAME <name>] [OPTIONAL])

       The FILES form specifies rules for installing files for a project.
       File names given as relative paths are interpreted with respect to the
       current source directory.  Files installed by this form are by default
       given permissions OWNER_WRITE, OWNER_READ, GROUP_READ, and WORLD_READ
       if no PERMISSIONS argument is given.

       The PROGRAMS signature:

         INSTALL(PROGRAMS files... DESTINATION <dir>
                 [PERMISSIONS permissions...]
                 [CONFIGURATIONS [Debug|Release|...]]
                 [COMPONENT <component>]
                 [RENAME <name>] [OPTIONAL])

       The PROGRAMS form is identical to the FILES form except that the
       default permissions for the installed file also include OWNER_EXECUTE,
       GROUP_EXECUTE, and WORLD_EXECUTE.  This form is intended to install
       programs that are not targets, such as shell scripts.  Use the TARGETS
       form to install targets built within the project.

       The DIRECTORY signature:

         INSTALL(DIRECTORY dirs... DESTINATION <dir>
                 [FILE_PERMISSIONS permissions...]
                 [DIRECTORY_PERMISSIONS permissions...]
                 [USE_SOURCE_PERMISSIONS]
                 [CONFIGURATIONS [Debug|Release|...]]
                 [COMPONENT <component>]
                 [[PATTERN <pattern> | REGEX <regex>]
                  [EXCLUDE] [PERMISSIONS permissions...]] [...])

       The DIRECTORY form installs contents of one or more directories to a
       given destination.  The directory structure is copied verbatim to the
       destination.  The last component of each directory name is appended to
       the destination directory but a trailing slash may be used to avoid
       this because it leaves the last component empty.  Directory names
       given as relative paths are interpreted with respect to the current
       source directory.  If no input directory names are given the
       destination directory will be created but nothing will be installed
       into it.  The FILE_PERMISSIONS and DIRECTORY_PERMISSIONS options
       specify permissions given to files and directories in the destination.
       If USE_SOURCE_PERMISSIONS is specified and FILE_PERMISSIONS is not,
       file permissions will be copied from the source directory structure.
       If no permissions are specified files will be given the default
       permissions specified in the FILES form of the command, and the
       directories will be given the default permissions specified in the
       PROGRAMS form of the command.  The PATTERN and REGEX options specify a
       globbing pattern or regular expression to match directories or files
       encountered during traversal of an input directory.  The full path to
       an input file or directory (with forward slashes) is matched against
       the expression.  A PATTERN will match only complete file names: the
       portion of the full path matching the pattern must occur at the end of
       the file name and be preceded by a slash.  A REGEX will match any
       portion of the full path but it may use '/' and '$' to simulate the
       PATTERN behavior.  Options following one of these matching expressions
       are applied only to files or directories matching them.  The EXCLUDE
       option will skip the matched file or directory.  The PERMISSIONS
       option overrides the permissions setting for the matched file or
       directory.  For example the code

         INSTALL(DIRECTORY icons scripts/ DESTINATION share/myproj
                 PATTERN "CVS" EXCLUDE
                 PATTERN "scripts/*"
                 PERMISSIONS OWNER_EXECUTE OWNER_WRITE OWNER_READ
                             GROUP_EXECUTE GROUP_READ)

       will install the icons directory to share/myproj/icons and the scripts
       directory to share/myproj.  The icons will get default file
       permissions, the scripts will be given specific permissions, and any
       CVS directories will be excluded.

       The SCRIPT and CODE signature:

         INSTALL([[SCRIPT <file>] [CODE <code>]] [...])

       The SCRIPT form will invoke the given CMake script files during
       installation.  If the script file name is a relative path it will be
       interpreted with respect to the current source directory.  The CODE
       form will invoke the given CMake code during installation.  Code is
       specified as a single argument inside a double-quoted string.  For
       example, the code

         INSTALL(CODE "MESSAGE(\"Sample install message.\")")

       will print a message during installation.

       NOTE: This command supercedes the INSTALL_TARGETS command and the
       target properties PRE_INSTALL_SCRIPT and POST_INSTALL_SCRIPT.  It also
       replaces the FILES forms of the INSTALL_FILES and INSTALL_PROGRAMS
       commands.  The processing order of these install rules relative to
       those generated by INSTALL_TARGETS, INSTALL_FILES, and
       INSTALL_PROGRAMS commands is not defined.


  INSTALL_FILES
       Old installation command.  Use the INSTALL command.

       This command has been superceded by the INSTALL command.  It is
       provided for compatibility with older CMake code.  The FILES form is
       directly replaced by the FILES form of the INSTALL command.  The
       regexp form can be expressed more clearly using the GLOB form of the
       FILE command.

         INSTALL_FILES(<dir> extension file file ...)

       Create rules to install the listed files with the given extension into
       the given directory.  Only files existing in the current source tree
       or its corresponding location in the binary tree may be listed.  If a
       file specified already has an extension, that extension will be
       removed first.  This is useful for providing lists of source files
       such as foo.cxx when you want the corresponding foo.h to be installed.
       A typical extension is '.h'.

         INSTALL_FILES(<dir> regexp)

       Any files in the current source directory that match the regular
       expression will be installed.

         INSTALL_FILES(<dir> FILES file file ...)

       Any files listed after the FILES keyword will be installed explicitly
       from the names given.  Full paths are allowed in this form.

       The directory <dir> is relative to the installation prefix, which is
       stored in the variable CMAKE_INSTALL_PREFIX.

  INSTALL_PROGRAMS
       Old installation command.  Use the INSTALL command.

       This command has been superceded by the INSTALL command.  It is
       provided for compatibility with older CMake code.  The FILES form is
       directly replaced by the PROGRAMS form of the INSTALL command.  The
       regexp form can be expressed more clearly using the GLOB form of the
       FILE command.

         INSTALL_PROGRAMS(<dir> file1 file2 [file3 ...])
         INSTALL_PROGRAMS(<dir> FILES file1 [file2 ...])

       Create rules to install the listed programs into the given directory.
       Use the FILES argument to guarantee that the file list version of the
       command will be used even when there is only one argument.

         INSTALL_PROGRAMS(<dir> regexp)

       In the second form any program in the current source directory that
       matches the regular expression will be installed.

       This command is intended to install programs that are not built by
       cmake, such as shell scripts.  See the TARGETS form of the INSTALL
       command to create installation rules for targets built by cmake.

       The directory <dir> is relative to the installation prefix, which is
       stored in the variable CMAKE_INSTALL_PREFIX.

  INSTALL_TARGETS
       Old installation command.  Use the INSTALL command.

       This command has been superceded by the INSTALL command.  It is
       provided for compatibility with older CMake code.

         INSTALL_TARGETS(<dir> [RUNTIME_DIRECTORY dir] target target)

       Create rules to install the listed targets into the given directory.
       The directory <dir> is relative to the installation prefix, which is
       stored in the variable CMAKE_INSTALL_PREFIX.  If RUNTIME_DIRECTORY is
       specified, then on systems with special runtime files (Windows DLL),
       the files will be copied to that directory.

  LINK_DIRECTORIES
       Specify directories in which to search for libraries.

         LINK_DIRECTORIES(directory1 directory2 ...)

       Specify the paths in which the linker should search for libraries.

  LINK_LIBRARIES
       Link libraries to all targets added later.

         LINK_LIBRARIES(library1 <debug | optimized> library2 ...)

       This is an old CMake command for linking libraries.  Use
       TARGET_LINK_LIBRARIES unless you have a good reason for every target
       to link to the same set of libraries.

       Specify a list of libraries to be linked into any following targets
       (typically added with the ADD_EXECUTABLE or ADD_LIBRARY calls).  This
       command is passed down to all subdirectories.  The debug and optimized
       strings may be used to indicate that the next library listed is to be
       used only for that specific type of build.

  LIST
       List operations.

         LIST(LENGTH <list> <output variable>)
         LIST(GET <list> <element index> [<element index> ...] <output variable>)
         LIST(APPEND <list> <element> [<element> ...])
         LIST(INSERT <list> <element_index> <element> [<element> ...])
         LIST(REMOVE_ITEM <list> <value> [<value> ...])
         LIST(REMOVE_AT <list> <index> [<index> ...])
         LIST(SORT <list>)
         LIST(REVERSE <list>)

       LENGTH will return a given list's length.

       GET will return list of elements specified by indices from the list.

       APPEND will append elements to the list.

       INSERT will insert elements to the list to the specified location.

       When specifying an index, negative value corresponds to index from the
       end of the list.

       REMOVE_AT and REMOVE_ITEM will remove item from the list.  The
       difference is that REMOVE_ITEM will remove the given items, while
       REMOVE_AT will remove the item at the given indices.


  LOAD_CACHE
       Load in the values from another project's CMake cache.

         LOAD_CACHE(pathToCacheFile READ_WITH_PREFIX
                    prefix entry1...)

       Read the cache and store the requested entries in variables with their
       name prefixed with the given prefix.  This only reads the values, and
       does not create entries in the local project's cache.

         LOAD_CACHE(pathToCacheFile [EXCLUDE entry1...]
                    [INCLUDE_INTERNALS entry1...])

       Load in the values from another cache and store them in the local
       project's cache as internal entries.  This is useful for a project
       that depends on another project built in a different tree.  EXCLUDE
       option can be used to provide a list of entries to be excluded.
       INCLUDE_INTERNALS can be used to provide a list of internal entries to
       be included.  Normally, no internal entries are brought in.  Use of
       this form of the command is strongly discouraged, but it is provided
       for backward compatibility.

  LOAD_COMMAND
       Load a command into a running CMake.

         LOAD_COMMAND(COMMAND_NAME <loc1> [loc2 ...])

       The given locations are searched for a library whose name is
       cmCOMMAND_NAME.  If found, it is loaded as a module and the command is
       added to the set of available CMake commands.  Usually, TRY_COMPILE is
       used before this command to compile the module.  If the command is
       successfully loaded a variable named

         CMAKE_LOADED_COMMAND_<COMMAND_NAME>

       will be set to the full path of the module that was loaded.  Otherwise
       the variable will not be set.

  MACRO
       Start recording a macro for later invocation as a command.

         MACRO(<name> [arg1 [arg2 [arg3 ...]]])
           COMMAND1(ARGS ...)
           COMMAND2(ARGS ...)
           ...
         ENDMACRO(<name>)

       Define a macro named <name> that takes arguments named arg1 arg2 arg3
       (...).  Commands listed after MACRO, but before the matching ENDMACRO,
       are not invoked until the macro is invoked.  When it is invoked, the
       commands recorded in the macro are first modified by replacing formal
       parameters (${arg1}) with the arguments passed, and then invoked as
       normal commands.  In addition to referencing the formal parameters you
       can reference the variable ARGC which will be set to the number of
       arguments passed into the function as well as ARGV0 ARGV1 ARGV2 ...
       which will have the actual values of the arguments passed in.  This
       facilitates creating macros with optional arguments.  Additionally
       ARGV holds the list of all arguments given to the macro and ARGN holds
       the list of argument pass the last expected argument.

  MAKE_DIRECTORY
       Old directory creation command.  Use the FILE command.

       This command has been superceded by the FILE(MAKE_DIRECTORY ...)
       command.  It is provided for compatibility with older CMake code.

         MAKE_DIRECTORY(directory)

       Creates the specified directory.  Full paths should be given.  Any
       parent directories that do not exist will also be created.  Use with
       care.

  MARK_AS_ADVANCED
       Mark cmake cached variables as advanced.

         MARK_AS_ADVANCED([CLEAR|FORCE] VAR VAR2 VAR...)

       Mark the named cached variables as advanced.  An advanced variable
       will not be displayed in any of the cmake GUIs unless the show
       advanced option is on.  If CLEAR is the first argument advanced
       variables are changed back to unadvanced.  If FORCE is the first
       argument, then the variable is made advanced.  If neither FORCE nor
       CLEAR is specified, new values will be marked as advanced, but if the
       variable already has an advanced/non-advanced state, it will not be
       changed.

  MATH
       Mathematical expressions.

         MATH(EXPR <output variable> <math expression>)

       EXPR evaluates mathematical expression and return result in the output
       variable.  Example mathematical expression is '5 * ( 10 + 13 )'.

  MESSAGE
       Display a message to the user.

         MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR]
                 "message to display" ...)

       By default the message is displayed in a pop up window (CMakeSetup),
       or in the stdout of cmake, or the error section of ccmake.  If the
       first argument is SEND_ERROR then an error is raised, and the generate
       phase will be skipped.  If the first argument is FATAL_ERROR, all
       processing is halted.  If the first argument is STATUS then the
       message is displayed in the progress line for the GUI, or with a -- in
       the command line cmake.

  OPTION
       Provides an option that the user can optionally select.

         OPTION(OPTION_VAR "help string describing option"
                [initial value])

       Provide an option for the user to select as ON or OFF.  If no initial
       value is provided, OFF is used.

  OUTPUT_REQUIRED_FILES
       Output a list of required source files for a specified source file.

         OUTPUT_REQUIRED_FILES(srcfile outputfile)

       Outputs a list of all the source files that are required by the
       specified srcfile.  This list is written into outputfile.  This is
       similar to writing out the dependencies for srcfile except that it
       jumps from .h files into .cxx, .c and .cpp files if possible.

  PROJECT
       Set a name for the entire project.

         PROJECT(projectname [CXX] [C] [Java])

       Sets the name of the project.  This creates the variables
       projectname_BINARY_DIR and projectname_SOURCE_DIR.  Optionally you can
       specify which languages your project supports.  By default all
       languages are supported.  If you do not have a C++ compiler, but want
       to build a c program with cmake, then use this option.

  QT_WRAP_CPP
       Create QT Wrappers.

         QT_WRAP_CPP(resultingLibraryName DestName
                     SourceLists ...)

       Produce moc files for all the .h files listed in the SourceLists.  The
       moc files will be added to the library using the DestName source list.

  QT_WRAP_UI
       Create QT user interfaces Wrappers.

         QT_WRAP_UI(resultingLibraryName HeadersDestName
                    SourcesDestName SourceLists ...)

       Produce .h and .cxx files for all the .ui files listed in the
       SourceLists.  The .h files will be added to the library using the
       HeadersDestNamesource list.  The .cxx files will be added to the
       library using the SourcesDestNamesource list.

  REMOVE
       Old list item removal command.  Use the LIST command.

       This command has been superceded by the LIST(REMOVE ...) command.  It
       is provided for compatibility with older CMake code.

         REMOVE(VAR VALUE VALUE ...)

       Removes VALUE from the variable VAR.  This is typically used to remove
       entries from a vector (e.g.  semicolon separated list).  VALUE is
       expanded.

  REMOVE_DEFINITIONS
       Removes -D define flags to the command line of C and C++ compilers.

         REMOVE_DEFINITIONS(-DFOO -DBAR ...)

       Removes flags from command line of C and C++ compilers.  This command
       can be used to remove any flag from a compile line, but the -D flag is
       accepted most C/C++ compilers.  Other flags may not be as portable.

  SEPARATE_ARGUMENTS
       Split space separated arguments into a semi-colon separated list.

         SEPARATE_ARGUMENTS(VARIABLE)

       Convert the value of VARIABLE to a semi-colon separated list.  All
       spaces are replaced with ';'.  This helps with generating command
       lines.

  SET
       Set a CMAKE variable to a given value.

         SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])

       Within CMake sets VAR to the value VALUE.  VALUE is expanded before
       VAR is set to it.  If CACHE is present, then the VAR is put in the
       cache.  TYPE and DOCSTRING are required.  TYPE is used by the CMake
       GUI to choose a widget with which the user sets a value.  The value
       for TYPE may be one of

         FILEPATH = File chooser dialog.
         PATH     = Directory chooser dialog.
         STRING   = Arbitrary string.
         BOOL     = Boolean ON/OFF checkbox.
         INTERNAL = No GUI entry (used for persistent variables).

       If TYPE is INTERNAL, then the VALUE is always written into the cache,
       replacing any values existing in the cache.  If it is not a cache
       variable, then this always writes into the current makefile.  The
       FORCE option will overwrite the cache value removing any changes by
       the user.

         SET(VAR VALUE1 ... VALUEN).

       In this case VAR is set to a semicolon separated list of values.

       VAR can be an environment variable such as:

         SET( ENV{PATH} /home/martink )

       in which case the environment variable will be set.

  SET_DIRECTORY_PROPERTIES
       Set a property of the directory.

         SET_DIRECTORY_PROPERTIES(PROPERTIES prop1 value1 prop2 value2)

       Set a property for the current directory and subdirectories.  If the
       property is not found, CMake will report an error.  The properties
       include: INCLUDE_DIRECTORIES, LINK_DIRECTORIES,
       INCLUDE_REGULAR_EXPRESSION, and ADDITIONAL_MAKE_CLEAN_FILES.

       ADDITIONAL_MAKE_CLEAN_FILES is a list of files that will be cleaned as
       a part of "make clean" stage.

  SET_SOURCE_FILES_PROPERTIES
       Source files can have properties that affect how they are built.

         SET_SOURCE_FILES_PROPERTIES(file1 file2 ...
                                     PROPERTIES prop1 value1
                                     prop2 value2 ...)

       Set properties on a file.  The syntax for the command is to list all
       the files you want to change, and then provide the values you want to
       set next.  You can make up your own properties as well.  The following
       are used by CMake.  The ABSTRACT flag (boolean) is used by some class
       wrapping commands.  If WRAP_EXCLUDE (boolean) is true then many
       wrapping commands will ignore this file.  If GENERATED (boolean) is
       true then it is not an error if this source file does not exist when
       it is added to a target.  Obviously, it must be created (presumably by
       a custom command) before the target is built.  If the HEADER_FILE_ONLY
       (boolean) property is true then dependency information is not created
       for that file (this is set automatically, based on the file's name's
       extension and is probably only used by Makefiles).  OBJECT_DEPENDS
       (string) adds dependencies to the object file.  COMPILE_FLAGS (string)
       is passed to the compiler as additional command line arguments when
       the source file is compiled.  If SYMBOLIC (boolean) is set to true the
       build system will be informed that the source file is not actually
       created on disk but instead used as a symbolic name for a build rule.

  SET_TARGET_PROPERTIES
       Targets can have properties that affect how they are built.

         SET_TARGET_PROPERTIES(target1 target2 ...
                               PROPERTIES prop1 value1
                               prop2 value2 ...)

       Set properties on a target.  The syntax for the command is to list all
       the files you want to change, and then provide the values you want to
       set next.  You can use any prop value pair you want and extract it
       later with the GET_TARGET_PROPERTY command.

       Properties that affect the name of a target's output file are as
       follows.  The PREFIX and SUFFIX properties override the default target
       name prefix (such as "lib") and suffix (such as ".so").  IMPORT_PREFIX
       and IMPORT_SUFFIX are the equivalent properties for the import library
       corresponding to a DLL (for SHARED library targets).  OUTPUT_NAME sets
       the real name of a target when it is built and can be used to help
       create two targets of the same name even though CMake requires unique
       logical target names.  There is also a <CONFIG>_OUTPUT_NAME that can
       set the output name on a per-configuration basis.  <CONFIG>_POSTFIX
       sets a postfix for the real name of the target when it is built under
       the configuration named by <CONFIG> (in upper-case, such as
       "DEBUG_POSTFIX").  The value of this property is initialized when the
       target is created to the value of the variable CMAKE_<CONFIG>_POSTFIX
       (except for executable targets because earlier CMake versions which
       did not use this variable for executables).

       The LINK_FLAGS property can be used to add extra flags to the link
       step of a target.  LINK_FLAGS_<CONFIG> will add to the configuration
       <CONFIG>, for example, DEBUG, RELEASE, MINSIZEREL, RELWITHDEBINFO.
       DEFINE_SYMBOL sets the name of the preprocessor symbol defined when
       compiling sources in a shared library.  If not set here then it is set
       to target_EXPORTS by default (with some substitutions if the target is
       not a valid C identifier).  This is useful for headers to know whether
       they are being included from inside their library our outside to
       properly setup dllexport/dllimport decorations.  The COMPILE_FLAGS
       property sets additional compiler flags used to build sources within
       the target.  It may also be used to pass additional preprocessor
       definitions.

       The LINKER_LANGUAGE property is used to change the tool used to link
       an executable or shared library.  The default is set the language to
       match the files in the library.  CXX and C are common values for this
       property.

       For shared libraries VERSION and SOVERSION can be used to specify the
       build version and api version respectively.  When building or
       installing appropriate symlinks are created if the platform supports
       symlinks and the linker supports so-names.  If only one of both is
       specified the missing is assumed to have the same version number.  For
       executables VERSION can be used to specify the build version.  When
       building or installing appropriate symlinks are created if the
       platform supports symlinks.  For shared libraries and executables on
       Windows the VERSION attribute is parsed to extract a "major.minor"
       version number.  These numbers are used as the image version of the
       binary.

       There are a few properties used to specify RPATH rules.  INSTALL_RPATH
       is a semicolon-separated list specifying the rpath to use in installed
       targets (for platforms that support it).  INSTALL_RPATH_USE_LINK_PATH
       is a boolean that if set to true will append directories in the linker
       search path and outside the project to the INSTALL_RPATH.
       SKIP_BUILD_RPATH is a boolean specifying whether to skip automatic
       generation of an rpath allowing the target to run from the build tree.
       BUILD_WITH_INSTALL_RPATH is a boolean specifying whether to link the
       target in the build tree with the INSTALL_RPATH.  This takes
       precedence over SKIP_BUILD_RPATH and avoids the need for relinking
       before installation.  INSTALL_NAME_DIR is a string specifying the
       directory portion of the "install_name" field of shared libraries on
       Mac OSX to use in the installed targets.  When the target is created
       the values of the variables CMAKE_INSTALL_RPATH,
       CMAKE_INSTALL_RPATH_USE_LINK_PATH, CMAKE_SKIP_BUILD_RPATH,
       CMAKE_BUILD_WITH_INSTALL_RPATH, and CMAKE_INSTALL_NAME_DIR are used to
       initialize these properties.

       PROJECT_LABEL can be used to change the name of the target in an IDE
       like visual studio.  VS_KEYWORD can be set to change the visual studio
       keyword, for example QT integration works better if this is set to
       Qt4VSv1.0.

       When a library is built CMake by default generates code to remove any
       existing library using all possible names.  This is needed to support
       libraries that switch between STATIC and SHARED by a user option.
       However when using OUTPUT_NAME to build a static and shared library of
       the same name using different logical target names the two targets
       will remove each other's files.  This can be prevented by setting the
       CLEAN_DIRECT_OUTPUT property to 1.

       The PRE_INSTALL_SCRIPT and POST_INSTALL_SCRIPT properties are the old
       way to specify CMake scripts to run before and after installing a
       target.  They are used only when the old INSTALL_TARGETS command is
       used to install the target.  Use the INSTALL command instead.

       The EXCLUDE_FROM_DEFAULT_BUILD property is used by the visual studio
       generators.  If it is set to 1 the target will not be part of the
       default build when you select "Build Solution".

  SET_TESTS_PROPERTIES
       Set a property of the tests.

         SET_TESTS_PROPERTIES(test1 [test2...] PROPERTIES prop1 value1 prop2 value2)

       Set a property for the tests.  If the property is not found, CMake
       will report an error.  The properties include:

       WILL_FAIL: If set to true, this will invert the pass/fail flag of the
       test.

       PASS_REGULAR_EXPRESSION: If set, the test output will be checked
       against the specified regular expressions and at least one of the
       regular expressions has to match, otherwise the test will fail.

         Example: PASS_REGULAR_EXPRESSION "TestPassed;All ok"

       FAIL_REGULAR_EXPRESSION: If set, if the output will match to one of
       specified regular expressions, the test will fail.

         Example: PASS_REGULAR_EXPRESSION "[^a-z]Error;ERROR;Failed"

       Both PASS_REGULAR_EXPRESSION and FAIL_REGULAR_EXPRESSION expect a list
       of regular expressions.


  SITE_NAME
       Set the given variable to the name of the computer.

         SITE_NAME(variable)


  SOURCE_GROUP
       Define a grouping for sources in the makefile.

         SOURCE_GROUP(name [REGULAR_EXPRESSION regex] [FILES src1 src2 ...])

       Defines a group into which sources will be placed in project files.
       This is mainly used to setup file tabs in Visual Studio.  Any file
       whose name is listed or matches the regular expression will be placed
       in this group.  If a file matches multiple groups, the LAST group that
       explicitly lists the file will be favored, if any.  If no group
       explicitly lists the file, the LAST group whose regular expression
       matches the file will be favored.

       The name of the group may contain backslashes to specify subgroups:

         SOURCE_GROUP(outer\\inner ...)

       For backwards compatibility, this command is also supports the format:

         SOURCE_GROUP(name regex)

  STRING
       String operations.

         STRING(REGEX MATCH <regular_expression>
                <output variable> <input> [<input>...])
         STRING(REGEX MATCHALL <regular_expression>
                <output variable> <input> [<input>...])
         STRING(REGEX REPLACE <regular_expression>
                <replace_expression> <output variable>
                <input> [<input>...])
         STRING(REPLACE <match_expression>
                <replace_expression> <output variable>
                <input> [<input>...])
         STRING(COMPARE EQUAL <string1> <string2> <output variable>)
         STRING(COMPARE NOTEQUAL <string1> <string2> <output variable>)
         STRING(COMPARE LESS <string1> <string2> <output variable>)
         STRING(COMPARE GREATER <string1> <string2> <output variable>)
         STRING(ASCII <number> [<number> ...] <output variable>)
         STRING(CONFIGURE <string1> <output variable>
                [@ONLY] [ESCAPE_QUOTES])
         STRING(TOUPPER <string1> <output variable>)
         STRING(TOLOWER <string1> <output variable>)
         STRING(LENGTH <string> <output variable>)
         STRING(SUBSTRING <string> <begin> <length> <output variable>)

       REGEX MATCH will match the regular expression once and store the match
       in the output variable.

       REGEX MATCHALL will match the regular expression as many times as
       possible and store the matches in the output variable as a list.

       REGEX REPLACE will match the regular expression as many times as
       possible and substitute the replacement expression for the match in
       the output.  The replace expression may refer to paren-delimited
       subexpressions of the match using \1, \2, ..., \9.  Note that two
       backslashes (\\1) are required in CMake code to get a backslash
       through argument parsing.

       REPLACE will match the given expression and substitute the replacement
       expression for the match in the output.  The replace expression may
       refer to paren-delimited subexpressions of the match using \1, \2,
       ..., \9.  Note that two backslashes (\\1) are required in CMake code
       to get a backslash through argument parsing.

       COMPARE EQUAL/NOTEQUAL/LESS/GREATER will compare the strings and store
       true or false in the output variable.

       ASCII will convert all numbers into corresponding ASCII characters.

       CONFIGURE will transform a string like CONFIGURE_FILE transforms a
       file.

       TOUPPER/TOLOWER will convert string to upper/lower characters.

       LENGTH will return a given string's length.

       SUBSTRING will return a substring of a given string.

  SUBDIR_DEPENDS
       Legacy command.  Does nothing.

         SUBDIR_DEPENDS(subdir dep1 dep2 ...)

       Does not do anything.  This command used to help projects order
       parallel builds correctly.  This functionality is now automatic.

  SUBDIRS
       Add a list of subdirectories to the build.

         SUBDIRS(dir1 dir2 ...[EXCLUDE_FROM_ALL exclude_dir1 exclude_dir2 ...] [PREORDER] )

       Add a list of subdirectories to the build.  The ADD_SUBDIRECTORY
       command should be used instead of SUBDIRS although SUBDIRS will still
       work.  This will cause any CMakeLists.txt files in the sub directories
       to be processed by CMake.  Any directories after the PREORDER flag are
       traversed first by makefile builds, the PREORDER flag has no effect on
       IDE projects.  Any directories after the EXCLUDE_FROM_ALL marker will
       not be included in the top level makefile or project file.  This is
       useful for having CMake create makefiles or projects for a set of
       examples in a project.  You would want CMake to generate makefiles or
       project files for all the examples at the same time, but you would not
       want them to show up in the top level project or be built each time
       make is run from the top.

  TARGET_LINK_LIBRARIES
       Link a target to given libraries.

         TARGET_LINK_LIBRARIES(target library1
                               <debug | optimized> library2
                               ...)

       Specify a list of libraries to be linked into the specified target.
       The debug and optimized strings may be used to indicate that the next
       library listed is to be used only for that specific type of build

  TRY_COMPILE
       Try compiling some code.

         TRY_COMPILE(RESULT_VAR bindir srcdir
                     projectName <targetname> <CMAKE_FLAGS <Flags>>
                     <OUTPUT_VARIABLE var>)

       Try compiling a program.  Return the success or failure in RESULT_VAR.
       If <target name> is specified then build just that target otherwise
       the all or ALL_BUILD target is built.

         TRY_COMPILE(RESULT_VAR bindir srcfile
                     <CMAKE_FLAGS <Flags>>
                     <COMPILE_DEFINITIONS <flags> ...>
                     <OUTPUT_VARIABLE var>)

       Try compiling a srcfile.  Return the success or failure in RESULT_VAR.
       CMAKE_FLAGS can be used to pass -DVAR:TYPE=VALUE flags to cmake.  Some
       extra flags that can be included are, INCLUDE_DIRECTORIES,
       LINK_DIRECTORIES, and LINK_LIBRARIES.  COMPILE_DEFINITIONS are
       -Ddefinition that will be passed to the compile line.  If srcfile is
       specified the files in bindir/CMakeFiles/CMakeTmp are cleaned
       automatically.  If OUTPUT_VARIABLE is specified, then the output from
       the build process is stored in the given variable.  TRY_COMPILE
       creates a CMakeList.txt file on the fly, and in that file it looks
       like this:

         ADD_DEFINITIONS( <expanded COMPILE_DEFINITIONS from calling cmake>)
         INCLUDE_DIRECTORIES(${INCLUDE_DIRECTORIES})
         LINK_DIRECTORIES(${LINK_DIRECTORIES})
         ADD_EXECUTABLE(cmTryCompileExec sources)
         TARGET_LINK_LIBRARIES(cmTryCompileExec ${LINK_LIBRARIES})


  TRY_RUN
       Try compiling and then running some code.

         TRY_RUN(RUN_RESULT_VAR COMPILE_RESULT_VAR
                 bindir srcfile <CMAKE_FLAGS <Flags>>
                 <COMPILE_DEFINITIONS <flags>>
                 <OUTPUT_VARIABLE var>
                 <ARGS <arg1> <arg2>...>)

       Try compiling a srcfile.  Return the success or failure in
       COMPILE_RESULT_VAR.  Then if the compile succeeded, run the executable
       and return the result in RUN_RESULT_VAR.  If the executable was built,
       but failed for to run for some reason, then RUN_RESULT_VAR will be set
       to FAILED_TO_RUN, and the output will be in the COMPILE_RESULT_VAR.
       OUTPUT_VARIABLE specifies the name of the variable to put all of the
       standard output and standard error into.

  USE_MANGLED_MESA
       Copy mesa headers for use in combination with system GL.

         USE_MANGLED_MESA(PATH_TO_MESA OUTPUT_DIRECTORY)

       The path to mesa includes, should contain gl_mangle.h.  The mesa
       headers are copied to the specified output directory.  This allows
       mangled mesa headers to override other GL headers by being added to
       the include directory path earlier.

  UTILITY_SOURCE
       Specify the source tree of a third-party utility.

         UTILITY_SOURCE(cache_entry executable_name
                        path_to_source [file1 file2 ...])

       When a third-party utility's source is included in the distribution,
       this command specifies its location and name.  The cache entry will
       not be set unless the path_to_source and all listed files exist.  It
       is assumed that the source tree of the utility will have been built
       before it is needed.

  VARIABLE_REQUIRES
       Assert satisfaction of an option's required variables.

         VARIABLE_REQUIRES(TEST_VARIABLE RESULT_VARIABLE
                           REQUIRED_VARIABLE1
                           REQUIRED_VARIABLE2 ...)

       The first argument (TEST_VARIABLE) is the name of the variable to be
       tested, if that variable is false nothing else is done.  If
       TEST_VARIABLE is true, then the next argument (RESULT_VARIABLE) is a
       variable that is set to true if all the required variables are set.
       The rest of the arguments are variables that must be true or not set
       to NOTFOUND to avoid an error.  If any are not true, an error is
       reported.

  VTK_MAKE_INSTANTIATOR
       Deprecated.  For use only in VTK 4.0.

         VTK_MAKE_INSTANTIATOR(className outSourceList
                               src-list1 [src-list2 ..]
                               EXPORT_MACRO exportMacro
                               [HEADER_LOCATION dir]
                               [GROUP_SIZE groupSize]
                               [INCLUDES [file1 file2 ..]])

       Generates a new class with the given name and adds its files to the
       given outSourceList.  It registers the classes from the other given
       source lists with vtkInstantiator when it is loaded.  The output
       source list should be added to the library with the classes it
       registers.  The EXPORT_MACRO argument must be given and followed by
       the export macro to use when generating the class (ex.
       VTK_COMMON_EXPORT).  The HEADER_LOCATION option must be followed by a
       path.  It specifies the directory in which to place the generated
       class's header file.  The generated class implementation files always
       go in the build directory corresponding to the CMakeLists.txt file
       containing the command.  This is the default location for the header.
       The INCLUDES option can be followed by a list of zero or more files.
       These files will be #included by the generated instantiator header,
       and can be used to gain access to the specified exportMacro in the C++
       code.

  VTK_WRAP_JAVA
       Deprecated.  For use only in VTK 4.0.

         VTK_WRAP_JAVA(resultingLibraryName SourceListName
                       class1 class2 ...)

       Create Java wrappers for VTK classes.

  VTK_WRAP_PYTHON
       Deprecated.  For use only in VTK 4.0.

         VTK_WRAP_PYTHON(resultingLibraryName SourceListName
                         class1 class2 ...)

       Create Python wrappers for VTK classes.

  VTK_WRAP_TCL
       Deprecated.  For use only in VTK 4.0.

         VTK_WRAP_TCL(resultingLibraryName [SOURCES]
                      SourceListName class1 class2 ...
                      [COMMANDS CommandName1 CommandName2 ...])

       Create Tcl wrappers for VTK classes.

  WHILE
       Evaluate a group of commands while a condition is true

         WHILE(condition)
           COMMAND1(ARGS ...)
           COMMAND2(ARGS ...)
           ...
         ENDWHILE(condition)

       All commands between WHILE and the matching ENDWHILE are recorded
       without being invoked.  Once the ENDWHILE is evaluated, the recorded
       list of commands is invoked as long as the condition is true.  The
       condition is evaulated using the same logic as the IF command.

  WRITE_FILE
       Write a message to a file.

         WRITE_FILE(filename "message to write"... [APPEND])

       The first argument is the file name, the rest of the arguments are
       messages to write.  If the argument APPEND is specified, then the
       message will be appended.

       NOTE 1: FILE WRITE and FILE APPEND do exactly the same as this one but
       add some more functionality.

       NOTE 2: When using WRITE_FILE the produced file cannot be used as an
       input to CMake (CONFIGURE_FILE, source file ...) because it will lead
       to an infinite loop.  Use CONFIGURE_FILE if you want to generate input
       files to CMake.

------------------------------------------------------------------------------
Standard CMake Modules

The following modules are provided with CMake.  They can be used with
INCLUDE(ModuleName).

  AddFileDependencies
       ADD_FILE_DEPENDENCIES(source_file depend_files...)

       Adds the given files as dependencies to source_file


  CheckCCompilerFlag
       Check whether the C compiler supports a given flag.

       CHECK_C_COMPILER_FLAG(FLAG VARIABLE)

         FLAG - the compiler flag
         VARIABLE - variable to store the result


  CheckCSourceCompiles
       macro which checks if the source code compiles

       CHECK_C_SOURCE_COMPILES(SOURCE VAR)

         SOURCE   - source code to try to compile
         VAR      - variable to store whether the source code compiled

       

       The following variables may be set before calling this macro to modify
       the way the check is run:

         CMAKE_REQUIRED_FLAGS = string of compile command line flags
         CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
         CMAKE_REQUIRED_INCLUDES = list of include directories
         CMAKE_REQUIRED_LIBRARIES = list of libraries to link


  CheckCSourceRuns
       macro which checks if the source code runs

       CHECK_C_SOURCE_RUNS(SOURCE VAR)

         SOURCE   - source code to try to compile
         VAR - variable to store size if the type exists.

       

       The following variables may be set before calling this macro to modify
       the way the check is run:

         CMAKE_REQUIRED_FLAGS = string of compile command line flags
         CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
         CMAKE_REQUIRED_INCLUDES = list of include directories
         CMAKE_REQUIRED_LIBRARIES = list of libraries to link


  CheckCXXCompilerFlag
       Check whether the CXX compiler supports a given flag.

       CHECK_CXX_COMPILER_FLAG(FLAG VARIABLE)

         FLAG - the compiler flag
         VARIABLE - variable to store the result


  CheckCXXSourceCompiles
       macro which checks if the source code compiles

       CHECK_CXX_SOURCE_COMPILES(SOURCE VAR)

         SOURCE - source code to try to compile
         VAR    - variable to store whether the source code compiled

       

       The following variables may be set before calling this macro to modify
       the way the check is run:

         CMAKE_REQUIRED_FLAGS = string of compile command line flags
         CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
         CMAKE_REQUIRED_INCLUDES = list of include directories
         CMAKE_REQUIRED_LIBRARIES = list of libraries to link


  CheckCXXSourceRuns
       macro which checks if the source code compiles

       CHECK_CXX_SOURCE_RUNS(SOURCE VAR)

         SOURCE - source code to try to compile
         VAR    - variable to store size if the type exists.

       

       The following variables may be set before calling this macro to modify
       the way the check is run:

         CMAKE_REQUIRED_FLAGS = string of compile command line flags
         CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
         CMAKE_REQUIRED_INCLUDES = list of include directories
         CMAKE_REQUIRED_LIBRARIES = list of libraries to link


  CheckFunctionExists
       macro which checks if the function exists

       CHECK_FUNCTION_EXISTS(FUNCTION VARIABLE)

         FUNCTION - the name of the function
         VARIABLE - variable to store the result

       

       The following variables may be set before calling this macro to modify
       the way the check is run:

         CMAKE_REQUIRED_FLAGS = string of compile command line flags
         CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
         CMAKE_REQUIRED_INCLUDES = list of include directories
         CMAKE_REQUIRED_LIBRARIES = list of libraries to link


  CheckIncludeFile
       macro which checks the include file exists.

       CHECK_INCLUDE_FILE(INCLUDE VARIABLE)

         INCLUDE  - name of include file
         VARIABLE - variable to return result
          

       an optional third argument is the CFlags to add to the compile line or
       you can use CMAKE_REQUIRED_FLAGS

       The following variables may be set before calling this macro to modify
       the way the check is run:

         CMAKE_REQUIRED_FLAGS = string of compile command line flags
         CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
         CMAKE_REQUIRED_INCLUDES = list of include directories

       


  CheckIncludeFileCXX
       Check if the include file exists.

         CHECK_INCLUDE_FILE_CXX(INCLUDE VARIABLE)

       

         INCLUDE  - name of include file
         VARIABLE - variable to return result
         

       An optional third argument is the CFlags to add to the compile line or
       you can use CMAKE_REQUIRED_FLAGS.

       The following variables may be set before calling this macro to modify
       the way the check is run:

         CMAKE_REQUIRED_FLAGS = string of compile command line flags
         CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
         CMAKE_REQUIRED_INCLUDES = list of include directories

       


  CheckIncludeFiles
       Check if the files can be included

       

       CHECK_INCLUDE_FILES(INCLUDE VARIABLE)

         INCLUDE  - list of files to include
         VARIABLE - variable to return result

       

       The following variables may be set before calling this macro to modify
       the way the check is run:

         CMAKE_REQUIRED_FLAGS = string of compile command line flags
         CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
         CMAKE_REQUIRED_INCLUDES = list of include directories


  CheckLibraryExists
       Check if the function exists.

       CHECK_LIBRARY_EXISTS (LIBRARY FUNCTION LOCATION VARIABLE)

         LIBRARY  - the name of the library you are looking for
         FUNCTION - the name of the function
         LOCATION - location where the library should be found
         VARIABLE - variable to store the result

       

       The following variables may be set before calling this macro to modify
       the way the check is run:

         CMAKE_REQUIRED_FLAGS = string of compile command line flags
         CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
         CMAKE_REQUIRED_LIBRARIES = list of libraries to link


  CheckSymbolExists
       Check if the symbol exists in include files

       CHECK_SYMBOL_EXISTS(SYMBOL FILES VARIABLE)

         SYMBOL   - symbol
         FILES    - include files to check
         VARIABLE - variable to return result

       

       The following variables may be set before calling this macro to modify
       the way the check is run:

         CMAKE_REQUIRED_FLAGS = string of compile command line flags
         CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
         CMAKE_REQUIRED_INCLUDES = list of include directories
         CMAKE_REQUIRED_LIBRARIES = list of libraries to link


  CheckTypeSize
       Check sizeof a type

         CHECK_TYPE_SIZE(TYPE VARIABLE)

       Check if the type exists and determine size of type.  if the type
       exists, the size will be stored to the variable.

         VARIABLE - variable to store size if the type exists.
         HAVE_${VARIABLE} - does the variable exists or not

       The following variables may be set before calling this macro to modify
       the way the check is run:

         CMAKE_REQUIRED_FLAGS = string of compile command line flags
         CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
         CMAKE_REQUIRED_INCLUDES = list of include directories
         CMAKE_REQUIRED_LIBRARIES = list of libraries to link


  CheckVariableExists
       Check if the variable exists.

         CHECK_VARIABLE_EXISTS(VAR VARIABLE)
         
         VAR      - the name of the variable
         VARIABLE - variable to store the result

       

       This macro is only for C variables.

       The following variables may be set before calling this macro to modify
       the way the check is run:

         CMAKE_REQUIRED_FLAGS = string of compile command line flags
         CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
         CMAKE_REQUIRED_LIBRARIES = list of libraries to link


  CMakeBackwardCompatibilityCXX
       define a bunch of backwards compatibility variables

         CMAKE_ANSI_CXXFLAGS - flag for ansi c++ 
         CMAKE_HAS_ANSI_STRING_STREAM - has <strstream>
         INCLUDE(TestForANSIStreamHeaders)
         INCLUDE(CheckIncludeFileCXX)
         INCLUDE(TestForSTDNamespace)
         INCLUDE(TestForANSIForScope)


  CMakeDependentOption
       Macro to provide an option dependent on other options.

       This macro presents an option to the user only if a set of other
       conditions are true.  When the option is not presented a default value
       is used, but any value set by the user is preserved for when the
       option is presented again.  Example invocation:

         CMAKE_DEPENDENT_OPTION(USE_FOO "Use Foo" ON
                                "USE_BAR;NOT USE_ZOT" OFF)

       If USE_BAR is true and USE_ZOT is false, this provides an option
       called USE_FOO that defaults to ON.  Otherwise, it sets USE_FOO to
       OFF.  If the status of USE_BAR or USE_ZOT ever changes, any value for
       the USE_FOO option is saved so that when the option is re-enabled it
       retains its old value.

  CMakeExportBuildSettings
       export build settings from a project.

         CMAKE_EXPORT_BUILD_SETTINGS(SETTINGS_FILE)

       macro defined to export the build settings for use by another project.

         SETTINGS_FILE - the file into which the settings are to be stored.


  CMakeFindFrameworks
       helper module to find OSX frameworks


  CMakeImportBuildSettings
       import build settings from another project

         CMAKE_IMPORT_BUILD_SETTINGS(SETTINGS_FILE) 

       macro defined to import the build settings from another project.
       SETTINGS_FILE is a file created by the other project's call to the
       CMAKE_EXPORT_BUILD_SETTINGS macro, see CMakeExportBuildSettings.

  CMakeJavaInformation
        

       This should be included before the _INIT variables are used to
       initialize the cache.  Since the rule variables have if blocks on
       them, users can still define them here.  But, it should still be after
       the platform file so changes can be made to those values.

  CMakePrintSystemInformation
       print system information

       This file can be used for diagnostic purposes just include it in a
       project to see various internal CMake variables.

  CPack
        

       Default output files will be CPackConfig.cmake and
       CPackSourceConfig.cmake.  This can be overwritten with
       CPACK_OUTPUT_CONFIG_FILE and CPACK_SOURCE_OUTPUT_CONFIG_FILE.

  CTest
       setup CTest

       This file configures a project to use the CTest/Dart testing/dashboard
       process.

  Dart
       setup for using Dart.

       This file configures a project to use the Dart testing/dashboard
       process.  It is broken into 3 sections.

  Documentation
       DocumentationVTK.cmake

       This file provides support for the VTK documentation framework.  It
       relies on several tools (Doxygen, Perl, etc).

  FindASPELL
       Try to find ASPELL

       Once done this will define

         ASPELL_FOUND - system has ASPELL
         ASPELL_INCLUDE_DIR - the ASPELL include directory
         ASPELL_LIBRARIES - The libraries needed to use ASPELL
         ASPELL_DEFINITIONS - Compiler switches required for using ASPELL


  FindAVIFile
       Locate AVIFILE library and include paths

       AVIFILE (http://avifile.sourceforge.net/)is a set of libraries for
       i386 machines to use various AVI codecs.  Support is limited beyond
       Linux.  Windows provides native AVI support, and so doesn't need this
       library.  This module defines

         AVIFILE_INCLUDE_DIR, where to find avifile.h , etc.
         AVIFILE_LIBRARIES, the libraries to link against
         AVIFILE_DEFINITIONS, definitions to use when compiling
         AVIFILE_FOUND, If false, don't try to use AVIFILE


  FindBoost
       Find the Boost includes and libraries.

       The following variables are set if Boost is found.  If Boost is not
       found, Boost_FOUND is set to false.

         Boost_FOUND        - True when the Boost include directory is found.
         Boost_INCLUDE_DIRS - the path to where the boost include files are.
         Boost_LIBRARY_DIRS - The path to where the boost library files are.
         Boost_LIB_DIAGNOSTIC_DEFINITIONS - Only set if using Windows.


  FindBZip2
       Try to find BZip2

       Once done this will define

         BZIP2_FOUND - system has BZip2
         BZIP2_INCLUDE_DIR - the BZip2 include directory
         BZIP2_LIBRARIES - Link these to use BZip2
         BZIP2_DEFINITIONS - Compiler switches required for using BZip2
         BZIP2_NEED_PREFIX - this is set if the functions are prefixed with BZ2_


  FindCABLE
       Find CABLE

       This module finds if CABLE is installed and determines where the
       include files and libraries are.  This code sets the following
       variables:

         CABLE             the path to the cable executable
         CABLE_TCL_LIBRARY the path to the Tcl wrapper library
         CABLE_INCLUDE_DIR the path to the include directory

       

       To build Tcl wrappers, you should add shared library and link it to
       ${CABLE_TCL_LIBRARY}.  You should also add ${CABLE_INCLUDE_DIR} as an
       include directory.

  FindCURL
       Find curl

       Find the native CURL headers and libraries.

         CURL_INCLUDE_DIRS - where to find curl/curl.h, etc.
         CURL_LIBRARIES    - List of libraries when using curl.
         CURL_FOUND        - True if curl found.


  FindCurses
       Find the curses include file and library

       


  FindCygwin
       this module looks for Cygwin

       


  FindDart
       Find DART

       This module looks for the dart testing software and sets DART_ROOT to
       point to where it found it.


  FindDCMTK
       find DCMTK libraries

       


  FindDoxygen
       This module looks for Doxygen and the path to Graphviz's dot

       Doxygen is a documentation generation tool see http://www.doxygen.org
       With the OS X GUI version, it likes to be installed to /Applications
       and it contains the doxygen executable in the bundle.  In the versions
       I've seen, it is located in Resources, but in general, more often
       binaries are located in MacOS.  This code sets the following
       variables:

         DOXYGEN_EXECUTABLE     = The path to the doxygen command.
         DOXYGEN_DOT_EXECUTABLE = The path to the dot program used by doxygen.
         DOXYGEN_DOT_PATH       = The path to dot not including the executable
         DOXYGEN = same as DOXYGEN_EXECUTABLE for backwards compatibility
         DOT = same as DOXYGEN_DOT_EXECUTABLE for backwards compatibility


  FindEXPAT
       Find expat

       Find the native EXPAT headers and libraries.

         EXPAT_INCLUDE_DIRS - where to find expat.h, etc.
         EXPAT_LIBRARIES    - List of libraries when using expat.
         EXPAT_FOUND        - True if expat found.


  FindFLTK
       Find the native FLTK includes and library

       The following settings are defined

         FLTK_FLUID_EXECUTABLE, where to find the Fluid tool
         FLTK_WRAP_UI, This enables the FLTK_WRAP_UI command
         FLTK_INCLUDE_DIR, where to find include files
         FLTK_LIBRARIES, list of fltk libraries
         FLTK_FOUND, Don't use FLTK if false.

       The following settings should not be used in general.

         FLTK_BASE_LIBRARY   = the full path to fltk.lib
         FLTK_GL_LIBRARY     = the full path to fltk_gl.lib
         FLTK_FORMS_LIBRARY  = the full path to fltk_forms.lib
         FLTK_IMAGES_LIBRARY = the full path to fltk_images.lib


  FindGCCXML
       Find the GCC-XML front-end executable.


  FindGLUT
       try to find glut library and include files

         GLUT_INCLUDE_DIR, where to find GL/glut.h, etc.
         GLUT_LIBRARIES, the libraries to link against
         GLUT_FOUND, If false, do not try to use GLUT.

       Also defined, but not for general use are:

         GLUT_glut_LIBRARY = the full path to the glut library.
         GLUT_Xmu_LIBRARY  = the full path to the Xmu library.
         GLUT_Xi_LIBRARY   = the full path to the Xi Library.


  FindGnuplot
       this module looks for gnuplot

       


  FindGTK
       try to find GTK (and glib) and GTKGLArea

         GTK_INCLUDE_DIR   - Directories to include to use GTK
         GTK_LIBRARIES     - Files to link against to use GTK
         GTK_FOUND         - GTK was found
         GTK_GL_FOUND      - GTK's GL features were found


  FindHSPELL
       Try to find HSPELL

       Once done this will define

         HSPELL_FOUND - system has HSPELL
         HSPELL_INCLUDE_DIR - the HSPELL include directory
         HSPELL_LIBRARIES - The libraries needed to use HSPELL
         HSPELL_DEFINITIONS - Compiler switches required for using HSPELL


  FindHTMLHelp
       This module looks for Microsoft HTML Help Compiler

       It defines:

          HTML_HELP_COMPILER     : full path to the Compiler (hhc.exe)
          HTML_HELP_INCLUDE_PATH : include path to the API (htmlhelp.h)
          HTML_HELP_LIBRARY      : full path to the library (htmlhelp.lib)

       


  FindImageMagick
       Find Image Magick

       This module finds if ImageMagick tools are installed and determines
       where the executables are.  This code sets the following variables:

         IMAGEMAGICK_CONVERT_EXECUTABLE   = 
            the full path to the 'convert' utility 
         IMAGEMAGICK_MOGRIFY_EXECUTABLE   = 
            the full path to the 'mogrify' utility 
         IMAGEMAGICK_IMPORT_EXECUTABLE    = 
            the full path to the 'import'  utility 
         IMAGEMAGICK_MONTAGE_EXECUTABLE   = 
            the full path to the 'montage' utility 
         IMAGEMAGICK_COMPOSITE_EXECUTABLE = 
            the full path to the 'composite' utility 

       


  FindITK
       Find an ITK installation or build tree.


  FindJasper
       Try to find the Jasper JPEG2000 library

       Once done this will define

         JASPER_FOUND - system has Jasper
         JASPER_INCLUDE_DIR - the Jasper include directory
         JASPER_LIBRARIES - The libraries needed to use Jasper


  FindJava
       Find Java

       This module finds if Java is installed and determines where the
       include files and libraries are.  This code sets the following
       variables:

         JAVA_RUNTIME    = the full path to the Java runtime
         JAVA_COMPILE    = the full path to the Java compiler
         JAVA_ARCHIVE    = the full path to the Java archiver

       


  FindJNI
       Find JNI java libraries.

       This module finds if Java is installed and determines where the
       include files and libraries are.  It also determines what the name of
       the library is.  This code sets the following variables:

          
         JAVA_AWT_LIB_PATH     = the path to the jawt library
         JAVA_JVM_LIB_PATH     = the path to the jvm library
         JAVA_INCLUDE_PATH     = the include path to jni.h
         JAVA_INCLUDE_PATH2    = the include path to jni.h
         JAVA_AWT_INCLUDE_PATH = the include path to jawt.h

       


  FindJPEG
       Find JPEG

       Find the native JPEG includes and library This module defines

         JPEG_INCLUDE_DIR, where to find jpeglib.h, etc.
         JPEG_LIBRARIES, the libraries needed to use JPEG.
         JPEG_FOUND, If false, do not try to use JPEG.

       also defined, but not for general use are

         JPEG_LIBRARY, where to find the JPEG library.


  FindKDE3
       Find the KDE3 include and library dirs, KDE preprocessors and define a
       some macros

       

       This module defines the following variables: KDE3_DEFINITIONS -
       compiler definitions required for compiling KDE software
       KDE3_INCLUDE_DIR - the KDE include directory KDE3_INCLUDE_DIRS - the
       KDE and the Qt include directory, for use with INCLUDE_DIRECTORIES()
       KDE3_LIB_DIR - the directory where the KDE libraries are installed,
       for use with LINK_DIRECTORIES() QT_AND_KDECORE_LIBS - this contains
       both the Qt and the kdecore library KDE3_DCOPIDL_EXECUTABLE - the
       dcopidl executable KDE3_DCOPIDL2CPP_EXECUTABLE - the dcopidl2cpp
       executable KDE3_KCFGC_EXECUTABLE - the kconfig_compiler executable
       KDE3_FOUND - set to TRUE if all of the above has been found

       The following user adjustable options are provided:

       KDE3_ENABLE_FINAL - enable this for KDE-style enable-final all-in-one
       compilation KDE3_BUILD_TESTS - enable this to build KDE testcases

       

       It also adds the following macros (from KDE3Macros.cmake) SRCS_VAR is
       always the variable which contains the list of source files for your
       application or library.

       KDE3_AUTOMOC(file1 ...  fileN)

           Call this if you want to have automatic moc file handling.
           This means if you include "foo.moc" in the source file foo.cpp
           a moc file for the header foo.h will be created automatically.
           You can set the property SKIP_AUTOMAKE using SET_SOURCE_FILES_PROPERTIES()
           to exclude some files in the list from being processed.

       

       KDE3_ADD_MOC_FILES(SRCS_VAR file1 ...  fileN )

           If you don't use the KDE3_AUTOMOC() macro, for the files
           listed here moc files will be created (named "foo.moc.cpp")

       

       KDE3_ADD_DCOP_SKELS(SRCS_VAR header1.h ...  headerN.h )

           Use this to generate DCOP skeletions from the listed headers.

       

       KDE3_ADD_DCOP_STUBS(SRCS_VAR header1.h ...  headerN.h )

            Use this to generate DCOP stubs from the listed headers.

       

       KDE3_ADD_UI_FILES(SRCS_VAR file1.ui ...  fileN.ui )

           Use this to add the Qt designer ui files to your application/library.

       

       KDE3_ADD_KCFG_FILES(SRCS_VAR file1.kcfgc ...  fileN.kcfgc )

           Use this to add KDE kconfig compiler files to your application/library.

       

       KDE3_INSTALL_LIBTOOL_FILE(target)

           This will create and install a simple libtool file for the given target.

       

       KDE3_ADD_EXECUTABLE(name file1 ...  fileN )

           Equivalent to ADD_EXECUTABLE(), but additionally supports KDE3_ENABLE_FINAL

       

       KDE3_ADD_KPART(name [WITH_PREFIX] file1 ...  fileN )

           Create a KDE plugin (KPart, kioslave, etc.) from the given source files.
           It supports KDE3_ENABLE_FINAL
           If WITH_PREFIX is given, the resulting plugin will have the prefix "lib", otherwise it won't.
           It creates and installs an appropriate libtool la-file.

       

       KDE3_ADD_KDEINIT_EXECUTABLE(name file1 ...  fileN )

           Create a KDE application in the form of a module loadable via kdeinit.
           A library named kdeinit_<name> will be created and a small executable which links to it.
           It supports KDE3_ENABLE_FINAL

       

       Author: Alexander Neundorf <neundorf@kde.org>

  FindKDE4
       /opt/kde

       Find KDE4 and provide all necessary variables and macros to compile
       software for it.  It looks for KDE 4 in the following directories in
       the given order:

       Please look in FindKDE4Internal.cmake and KDE4Macros.cmake for more
       information.  They are installed with the KDE 4 libraries in
       $KDEDIR/share/apps/cmake/modules/.

       Author: Alexander Neundorf <neundorf@kde.org>

  FindLATEX
       Find Latex

       This module finds if Latex is installed and determines where the
       executables are.  This code sets the following variables:

         
         LATEX_COMPILER:       path to the LaTeX compiler
         PDFLATEX_COMPILER:    path to the PdfLaTeX compiler
         BIBTEX_COMPILER:      path to the BibTeX compiler
         MAKEINDEX_COMPILER:   path to the MakeIndex compiler
         DVIPS_CONVERTER:      path to the DVIPS converter
         PS2PDF_CONVERTER:     path to the PS2PDF converter
         LATEX2HTML_CONVERTER: path to the LaTeX2Html converter 

       


  FindLibXml2
       Try to find LibXml2

       Once done this will define

         LIBXML2_FOUND - system has LibXml2
         LIBXML2_INCLUDE_DIR - the LibXml2 include directory
         LIBXML2_LIBRARIES - the libraries needed to use LibXml2
         LIBXML2_DEFINITIONS - Compiler switches required for using LibXml2

       

       Copyright (c) 2006, Alexander Neundorf <neundorf@kde.org> This code is
       available under the BSD license, see licenses/BSD for details.

  FindLibXslt
       Try to find LibXslt

       Once done this will define

         LIBXSLT_FOUND - system has LibXslt
         LIBXSLT_INCLUDE_DIR - the LibXslt include directory
         LIBXSLT_LIBRARIES - Link these to LibXslt
         LIBXSLT_DEFINITIONS - Compiler switches required for using LibXslt


  FindMatlab
       this module looks for Matlab

       Defines:

         MATLAB_INCLUDE_DIR: include path for mex.h, engine.h
         MATLAB_LIBRARIES:   required libraries: libmex, etc
         MATLAB_MEX_LIBRARY: path to libmex.lib
         MATLAB_MX_LIBRARY:  path to libmx.lib
         MATLAB_ENG_LIBRARY: path to libeng.lib


  FindMFC
       Find MFC on Windows

       Find the native MFC - i.e.  decide if this is an MS VC box.

         MFC_FOUND - Was MFC support found

       You don't need to include anything or link anything to use it.

  FindMotif
       Try to find Motif (or lesstif)

       Once done this will define:

         MOTIF_FOUND        - system has MOTIF
         MOTIF_INCLUDE_DIR  - incude paths to use Motif
         MOTIF_LIBRARIES    - Link these to use Motif


  FindMPEG
       Find the native MPEG includes and library

       This module defines

         MPEG_INCLUDE_DIR, where to find MPEG.h, etc.
         MPEG_LIBRARIES, the libraries required to use MPEG.
         MPEG_FOUND, If false, do not try to use MPEG.

       also defined, but not for general use are

         MPEG_mpeg2_LIBRARY, where to find the MPEG library.
         MPEG_vo_LIBRARY, where to find the vo library.


  FindMPEG2
       Find the native MPEG2 includes and library

       This module defines

         MPEG2_INCLUDE_DIR, path to mpeg2dec/mpeg2.h, etc.
         MPEG2_LIBRARIES, the libraries required to use MPEG2.
         MPEG2_FOUND, If false, do not try to use MPEG2.

       also defined, but not for general use are

         MPEG2_mpeg2_LIBRARY, where to find the MPEG2 library.
         MPEG2_vo_LIBRARY, where to find the vo library.


  FindMPI
       Find MPI

       This module looks for MPI (Message Passing Interface) support it will
       define the following values

         MPI_INCLUDE_PATH = where mpi.h can be found
         MPI_LIBRARY    = the library to link in (mpi mpich etc)


  FindOpenAL
       Locate OpenAL

       This module defines

         OPENAL_LIBRARY
         OPENAL_FOUND, if false, do not try to link to OpenAL 
         OPENAL_INCLUDE_DIR, where to find the headers
          

       $OPENALDIR is an environment variable that would correspond to the
       ./configure --prefix=$OPENALDIR used in building OpenAL.

          

       Created by Eric Wing.  This was influenced by the FindSDL.cmake
       module.  On OSX, this will prefer the Framework version (if found)
       over others.  People will have to manually change the cache values of
       OPENAL_LIBRARY to override this selection.  Tiger will include OpenAL
       as part of the System.  But for now, we have to look around.  Other
       (Unix) systems should be able to utilize the non-framework paths.

  FindOpenGL
       Try to find OpenGL

       Once done this will define

         
         OPENGL_FOUND        - system has OpenGL
         OPENGL_XMESA_FOUND  - system has XMESA
         OPENGL_GLU_FOUND    - system has GLU
         OPENGL_INCLUDE_DIR  - the GL include directory
         OPENGL_LIBRARIES    - Link these to use OpenGL and GLU
          

       If you want to use just GL you can use these values

         OPENGL_gl_LIBRARY   - Path to OpenGL Library
         OPENGL_glu_LIBRARY  - Path to GLU Library
         

       On OSX default to using the framework version of opengl People will
       have to change the cache values of OPENGL_glu_LIBRARY and
       OPENGL_gl_LIBRARY to use OpenGL with X11 on OSX

  FindOpenSSL
       Try to find the OpenSSL encryption library

       Once done this will define

         OPENSSL_FOUND - system has the OpenSSL library
         OPENSSL_INCLUDE_DIR - the OpenSSL include directory
         OPENSSL_LIBRARIES - The libraries needed to use OpenSSL


  FindPerl
       Find perl

       this module looks for Perl

         PERL_EXECUTABLE - the full path to perl
         PERL_FOUND      - If false, don't attempt to use perl.


  FindPerlLibs
       Find Perl libraries

       This module finds if PERL is installed and determines where the
       include files and libraries are.  It also determines what the name of
       the library is.  This code sets the following variables:

         PERL_INCLUDE_PATH = path to where perl.h is found
         PERL_EXECUTABLE   = full path to the perl binary

       


  FindPHP4
       Find PHP4

       This module finds if PHP4 is installed and determines where the
       include files and libraries are.  It also determines what the name of
       the library is.  This code sets the following variables:

         PHP4_INCLUDE_PATH       = path to where php.h can be found
         PHP4_EXECUTABLE         = full path to the php4 binary

       


  FindPhysFS
       Locate PhysFS library

       This module defines

         PHYSFS_LIBRARY, the name of the library to link with
         PHYSFS_FOUND, if false, do not try to link to PHYSFS
         PHYSFS_INCLUDE_DIR, where to find PHYSFS/PHYSFS.h

       

       $PHYSFSDIR is an environment variable that would correspond to the
       ./configure --prefix=$PHYSFSDIR used in building PHYSFS.

       Created by Eric Wing.  This was influenced by the FindSDL.cmake
       module, but with modifications to recognize OS X frameworks.

  FindPike
       Find Pike

       This module finds if PIKE is installed and determines where the
       include files and libraries are.  It also determines what the name of
       the library is.  This code sets the following variables:

         PIKE_INCLUDE_PATH       = path to where program.h is found
         PIKE_EXECUTABLE         = full path to the pike binary

       


  FindPNG
       Find the native PNG includes and library

       


  FindPythonInterp
       Find python interpreter

       This module finds if Python interpreter is installed and determines
       where the executables are.  This code sets the following variables:

         PYTHONINTERP_FOUND - Was the Python executable found
         PYTHON_EXECUTABLE  - path to the Python interpreter

       


  FindPythonLibs
       Find python libraries

       This module finds if Python is installed and determines where the
       include files and libraries are.  It also determines what the name of
       the library is.  This code sets the following variables:

         PYTHON_LIBRARIES     = path to the python library
         PYTHON_INCLUDE_PATH  = path to where Python.h is found
         PYTHON_DEBUG_LIBRARIES = path to the debug library

       


  FindQt
       Searches for all installed versions of QT.

       This should only be used if your project can work with multiple
       versions of QT.  If not, you should just directly use FindQt4 or
       FindQt3.  If multiple versions of QT are found on the machine, then
       The user must set the option DESIRED_QT_VERSION to the version they
       want to use.  If only one version of qt is found on the machine, then
       the DESIRED_QT_VERSION is set to that version and the matching FindQt3
       or FindQt4 module is included.  Once the user sets DESIRED_QT_VERSION,
       then the FindQt3 or FindQt4 module is included.

         QT_REQUIRED if this is set to TRUE then if CMake can 
                     not find QT4 or QT3 an error is raised 
                     and a message is sent to the user.

       

         DESIRED_QT_VERSION OPTION is created
         QT4_INSTALLED is set to TRUE if qt4 is found.
         QT3_INSTALLED is set to TRUE if qt3 is found.


  FindQt3
       Locate Qt include paths and libraries

       This module defines:

         QT_INCLUDE_DIR - where to find qt.h, etc.
         QT_LIBRARIES   - the libraries to link against to use Qt.
         QT_DEFINITIONS - definitions to use when 
                          compiling code that uses Qt.
         QT_FOUND       - If false, don't try to use Qt.

       

       If you need the multithreaded version of Qt, set QT_MT_REQUIRED to
       TRUE

       Also defined, but not for general use are:

         QT_MOC_EXECUTABLE, where to find the moc tool.
         QT_UIC_EXECUTABLE, where to find the uic tool.
         QT_QT_LIBRARY, where to find the Qt library.
         QT_QTMAIN_LIBRARY, where to find the qtmain 
          library. This is only required by Qt3 on Windows.


  FindQt4
       Find QT 4

       This module can be used to find Qt4.  The most important issue is that
       the Qt4 qmake is available via the system path.  This qmake is then
       used to detect basically everything else.  This module defines a
       number of key variables and macros.  First is QT_USE_FILE which is the
       path to a CMake file that can be included to compile Qt 4 applications
       and libraries.  By default, the QtCore and QtGui libraries are loaded.
       This behavior can be changed by setting one or more of the following
       variables to true:

                           QT_DONT_USE_QTCORE
                           QT_DONT_USE_QTGUI
                           QT_USE_QT3SUPPORT
                           QT_USE_QTASSISTANT
                           QT_USE_QTDESIGNER
                           QT_USE_QTMOTIF
                           QT_USE_QTMAIN
                           QT_USE_QTNETWORK
                           QT_USE_QTNSPLUGIN
                           QT_USE_QTOPENGL
                           QT_USE_QTSQL
                           QT_USE_QTXML
                           QT_USE_QTSVG
                           QT_USE_QTTEST
                           QT_USE_QTUITOOLS

       

       All the libraries required are stored in a variable called
       QT_LIBRARIES.  Add this variable to your TARGET_LINK_LIBRARIES.

         
         macro QT4_WRAP_CPP(outfiles inputfile ... )
         macro QT4_WRAP_UI(outfiles inputfile ... )
         macro QT4_ADD_RESOURCE(outfiles inputfile ... )
         macro QT4_AUTOMOC(inputfile ... )
         macro QT4_GENERATE_MOC(inputfile outputfile )
         
         QT_FOUND         If false, don't try to use Qt.
         QT4_FOUND        If false, don't try to use Qt 4.
                             
         QT_QTCORE_FOUND        True if QtCore was found.
         QT_QTGUI_FOUND         True if QtGui was found.
         QT_QT3SUPPORT_FOUND    True if Qt3Support was found.
         QT_QTASSISTANT_FOUND   True if QtAssistant was found.
         QT_QTDESIGNER_FOUND    True if QtDesigner was found.
         QT_QTMOTIF_FOUND       True if QtMotif was found.
         QT_QTNETWORK_FOUND     True if QtNetwork was found.
         QT_QTNSPLUGIN_FOUND    True if QtNsPlugin was found.
         QT_QTOPENGL_FOUND      True if QtOpenGL was found.
         QT_QTSQL_FOUND         True if QtSql was found.
         QT_QTXML_FOUND         True if QtXml was found.
         QT_QTSVG_FOUND         True if QtSvg was found.
         QT_QTTEST_FOUND        True if QtTest was found.
         QT_QTUITOOLS_FOUND     True if QtUiTools was found.
                             
         QT_DEFINITIONS   Definitions to use when compiling code that uses Qt.
                         
         QT_INCLUDES      List of paths to all include directories of 
                          Qt4 QT_INCLUDE_DIR and QT_QTCORE_INCLUDE_DIR are
                          always in this variable even if NOTFOUND,
                          all other INCLUDE_DIRS are
                          only added if they are found.
          
         QT_INCLUDE_DIR              Path to "include" of Qt4
         QT_QT_INCLUDE_DIR           Path to "include/Qt" 
         QT_QT3SUPPORT_INCLUDE_DIR   Path to "include/Qt3Support" 
         QT_QTASSISTANT_INCLUDE_DIR  Path to "include/QtAssistant" 
         QT_QTCORE_INCLUDE_DIR       Path to "include/QtCore"         
         QT_QTDESIGNER_INCLUDE_DIR   Path to "include/QtDesigner" 
         QT_QTGUI_INCLUDE_DIR        Path to "include/QtGui" 
         QT_QTMOTIF_INCLUDE_DIR      Path to "include/QtMotif" 
         QT_QTNETWORK_INCLUDE_DIR    Path to "include/QtNetwork" 
         QT_QTNSPLUGIN_INCLUDE_DIR   Path to "include/QtNsPlugin" 
         QT_QTOPENGL_INCLUDE_DIR     Path to "include/QtOpenGL" 
         QT_QTSQL_INCLUDE_DIR        Path to "include/QtSql" 
         QT_QTXML_INCLUDE_DIR        Path to "include/QtXml" 
         QT_QTSVG_INCLUDE_DIR        Path to "include/QtSvg"
         QT_QTTEST_INCLUDE_DIR       Path to "include/QtTest"
                                   
         QT_LIBRARY_DIR              Path to "lib" of Qt4
                                   
         QT_PLUGINS_DIR              Path to "plugins" for Qt4
                                   

       For every library of Qt there are three variables:

         QT_QTFOO_LIBRARY_RELEASE, which contains the full path to the release version
         QT_QTFOO_LIBRARY_DEBUG, which contains the full path to the debug version
         QT_QTFOO_LIBRARY, the full path to the release version if available, otherwise to the debug version

       

       So there are the following variables: The Qt3Support library:
       QT_QT3SUPPORT_LIBRARY

                                    QT_QT3SUPPORT_LIBRARY_RELEASE
                                    QT_QT3SUPPORT_DEBUG

       

       The QtAssistant library: QT_QTASSISTANT_LIBRARY

                                    QT_QTASSISTANT_LIBRARY_RELEASE
                                    QT_QTASSISTANT_LIBRARY_DEBUG

       

       The QtCore library: QT_QTCORE_LIBRARY

                                    QT_QTCORE_LIBRARY_RELEASE
                                    QT_QTCORE_LIBRARY_DEBUG

       

       The QtDesigner library: QT_QTDESIGNER_LIBRARY

                                    QT_QTDESIGNER_LIBRARY_RELEASE
                                    QT_QTDESIGNER_LIBRARY_DEBUG

       

       The QtGui library: QT_QTGUI_LIBRARY

                                    QT_QTGUI_LIBRARY_RELEASE
                                    QT_QTGUI_LIBRARY_DEBUG

       

       The QtMotif library: QT_QTMOTIF_LIBRARY

                                    QT_QTMOTIF_LIBRARY_RELEASE
                                    QT_QTMOTIF_LIBRARY_DEBUG

       

       The QtNetwork library: QT_QTNETWORK_LIBRARY

                                    QT_QTNETWORK_LIBRARY_RELEASE
                                    QT_QTNETWORK_LIBRARY_DEBUG

       

       The QtNsPLugin library: QT_QTNSPLUGIN_LIBRARY

                                    QT_QTNSPLUGIN_LIBRARY_RELEASE
                                    QT_QTNSPLUGIN_LIBRARY_DEBUG

       

       The QtOpenGL library: QT_QTOPENGL_LIBRARY

                                    QT_QTOPENGL_LIBRARY_RELEASE
                                    QT_QTOPENGL_LIBRARY_DEBUG

       

       The QtSql library: QT_QTSQL_LIBRARY

                                    QT_QTSQL_LIBRARY_RELEASE
                                    QT_QTSQL_LIBRARY_DEBUG

       

       The QtXml library: QT_QTXML_LIBRARY

                                    QT_QTXML_LIBRARY_RELEASE
                                    QT_QTXML_LIBRARY_DEBUG

       

       The QtSvg library: QT_QTSVG_LIBRARY

                                    QT_QTSVG_LIBRARY_RELEASE
                                    QT_QTSVG_LIBRARY_DEBUG

       

       The QtTest library: QT_QTTEST_LIBRARY

                                    QT_QTTEST_LIBRARY_RELEASE
                                    QT_QTTEST_LIBRARY_DEBUG

       

       The qtmain library for Windows QT_QTMAIN_LIBRARY

                                    QT_QTMAIN_LIBRARY_RELEASE
                                    QT_QTMAIN_LIBRARY_DEBUG

       

       The QtUiTools library: QT_QTUITOOLS_LIBRARY

                                    QT_QTUITOOLS_LIBRARY_RELEASE
                                    QT_QTUITOOLS_LIBRARY_DEBUG
         

       also defined, but NOT for general use are

         QT_MOC_EXECUTABLE          Where to find the moc tool.
         QT_UIC_EXECUTABLE          Where to find the uic tool.
         QT_UIC3_EXECUTABLE         Where to find the uic3 tool.
         QT_RCC_EXECUTABLE          Where to find the rcc tool
         
         QT_DOC_DIR                 Path to "doc" of Qt4
         QT_MKSPECS_DIR             Path to "mkspecs" of Qt4

       

       

       These are around for backwards compatibility they will be set

         QT_WRAP_CPP  Set true if QT_MOC_EXECUTABLE is found
         QT_WRAP_UI   Set true if QT_UIC_EXECUTABLE is found
         

       These variables do _NOT_ have any effect anymore (compared to
       FindQt.cmake)

         QT_MT_REQUIRED         Qt4 is now always multithreaded
         

       These variables are set to "" Because Qt structure changed (They make
       no sense in Qt4)

         QT_QT_LIBRARY        Qt-Library is now split


  FindRuby
       Find Ruby

       This module finds if Ruby is installed and determines where the
       include files and libraries are.  It also determines what the name of
       the library is.  This code sets the following variables:

         RUBY_INCLUDE_PATH = path to where ruby.h can be found
         RUBY_EXECUTABLE   = full path to the ruby binary


  FindSDL
       Locate the SDL library

       This module defines

         SDL_LIBRARY, the library to link against
         SDL_FOUND, if false, do not try to link to SDL
         SDL_INCLUDE_DIR, where to find SDL.h

       

       Don't forget to include SDLmain.h and SDLmain.m your project for the
       OS X framework based version.  (Other versions link to -lSDLmain which
       this module will try to find on your behalf.) Also for OS X, this
       module will automatically add the -framework Cocoa on your behalf.
       $SDLDIR is an environment variable that would correspond to the
       ./configure --prefix=$SDLDIR used in building SDL.  l.e.galup 9-20-02

       Modified by Eric Wing.  Added new modifications to recognize OS X
       frameworks and additional Unix paths (FreeBSD, etc).  Also corrected
       the header search path to follow "proper" SDL guidelines.  Added a
       search for SDLmain which is needed by some platforms.  Added a search
       for threads which is needed by some platforms.  Added needed compile
       switches for MinGW.

       On OSX, this will prefer the Framework version (if found) over others.
       People will have to manually change the cache values of SDL_LIBRARY to
       override this selection.

       Note that the header path has changed from SDL/SDL.h to just SDL.h
       This needed to change because "proper" SDL convention is #include
       "SDL.h", not <SDL/SDL.h>.  This is done for portability reasons
       because not all systems place things in SDL/ (see FreeBSD).

  FindSDL_image
       Locate SDL_image library

       This module defines

         SDLIMAGE_LIBRARY, the library to link against
         SDLIMAGE_FOUND, if false, do not try to link to SDL
         SDLIMAGE_INCLUDE_DIR, where to find SDL/SDL.h

       

       $SDLDIR is an environment variable that would correspond to the
       ./configure --prefix=$SDLDIR used in building SDL.

       Created by Eric Wing.  This was influenced by the FindSDL.cmake
       module, but with modifications to recognize OS X frameworks and
       additional Unix paths (FreeBSD, etc).

  FindSDL_mixer
       Locate the SDL_mixer library

       This module defines

         SDLMIXER_LIBRARY, library to link against
         SDLMIXER_FOUND, if false, do not try to link to SDL
         SDLMIXER_INCLUDE_DIR, where to find SDL/SDL.h

       

       $SDLDIR is an environment variable that would correspond to the
       ./configure --prefix=$SDLDIR used in building SDL.

       Created by Eric Wing.  This was influenced by the FindSDL.cmake
       module, but with modifications to recognize OS X frameworks and
       additional Unix paths (FreeBSD, etc).

  FindSDL_net
       Locate the SDL_net library

       This module defines

         SDLNET_LIBRARY, the library to link against
         SDLNET_FOUND, if false, do not try to link against
         SDLNET_INCLUDE_DIR, where to find the headers
         

       $SDLDIR is an environment variable that would correspond to the
       ./configure --prefix=$SDLDIR used in building SDL.

         

       Created by Eric Wing.  This was influenced by the FindSDL.cmake
       module, but with modifications to recognize OS X frameworks and
       additional Unix paths (FreeBSD, etc).  On OSX, this will prefer the
       Framework version (if found) over others.  People will have to
       manually change the cache values of SDLNET_LIBRARY to override this
       selection.

  FindSDL_sound
       Locates the SDL_sound library

       This module depends on SDL being found and must be called AFTER
       FindSDL.cmake is called.

       This module defines SDL_SOUND_INCLUDE_DIR, where to find SDL_sound.h
       SDL_SOUND_FOUND, if false, do not try to link to SDL
       SDL_SOUND_LIBRARIES, this contains the list of libraries that you need
       to link against.  This is a read-only variable and is marked INTERNAL.
       SDL_SOUND_EXTRAS, this is an optional variable for you to add your own
       flags to SDL_SOUND_LIBRARIES.  This is prepended to
       SDL_SOUND_LIBRARIES.  This is available mostly for cases this module
       failed to anticipate for and you must add additional flags.  This is
       marked as ADVANCED.

       This module also defines (but you shouldn't need to use directly)
       SDL_SOUND_LIBRARY, the name of just the SDL_sound library you would
       link against.  Use SDL_SOUND_LIBRARIES for you link instructions and
       not this one.  And might define the following as needed

         MIKMOD_LIBRARY
         MODPLUG_LIBRARY
         OGG_LIBRARY
         VORBIS_LIBRARY
         SMPEG_LIBRARY
         FLAC_LIBRARY
         SPEEX_LIBRARY

       

       Typically, you should not use these variables directly, and you should
       use SDL_SOUND_LIBRARIES which contains SDL_SOUND_LIBRARY and the other
       audio libraries (if needed) to successfully compile on your system .

       Created by Eric Wing.

       This module is a bit more complicated than the other FindSDL* family
       modules.  The reason is that SDL_sound can be compiled in a large
       variety of different ways which are independent of platform.
       SDL_sound may dynamically link against other 3rd party libraries to
       get additional codec support, such as Ogg Vorbis, SMPEG, ModPlug,
       MikMod, FLAC, Speex, and potentially others.  Under some circumstances
       which I don't fully understand, there seems to be a requirement that
       dependent libraries of libraries you use must also be explicitly
       linked against in order to successfully compile.  SDL_sound does not
       currently have any system in place to know how it was compiled.  So
       this CMake module does the hard work in trying to discover which 3rd
       party libraries are required for building (if any).

       This module uses a brute force approach to create a test program that
       uses SDL_sound, and then tries to build it.  If the build fails, it
       parses the error output for known symbol names to figure out which
       libraries are needed.  Responds to the $SDLDIR and $SDLSOUNDDIR
       environmental variable that would correspond to the ./configure
       --prefix=$SDLDIR used in building SDL.

       On OSX, this will prefer the Framework version (if found) over others.
       People will have to manually change the cache values of SDL_LIBRARY to
       override this selection.


  FindSDL_ttf
       Locate SDL_ttf library

       This module defines

         SDLTTF_LIBRARY, the library to link against
         SDLTTF_FOUND, if false, do not try to link to SDL
         SDLTTF_INCLUDE_DIR, where to find SDL/SDL.h
          

       $SDLDIR is an environment variable that would correspond to the
       ./configure --prefix=$SDLDIR used in building SDL.  Created by Eric
       Wing.  This was influenced by the FindSDL.cmake module, but with
       modifications to recognize OS X frameworks and additional Unix paths
       (FreeBSD, etc).  On OSX, this will prefer the Framework version (if
       found) over others.  People will have to manually change the cache
       values of SDLTTF_LIBRARY to override this selection.

  FindSelfPackers
       Find upx

       This module looks for some executable packers (i.e.  softwares that
       compress executables or shared libs into on-the-fly self-extracting
       executables or shared libs.  Examples:

         UPX: http://wildsau.idv.uni-linz.ac.at/mfx/upx.html


  FindSubversion
       Extract information from a subversion working copy

       The module defines the following variables:

         Subversion_SVN_EXECUTABLE - path to svn command line client
         Subversion_VERSION_SVN - version of svn command line client
         Subversion_FOUND - true if the command line client was found

       If the command line client executable is found the macro

         Subversion_WC_INFO(<dir> <var-prefix>)

       is defined to extract information of a subversion working copy at a
       given location.  The macro defines the following variables:

         <var-prefix>_WC_URL - url of the repository (at <dir>)
         <var-prefix>_WC_ROOT - root url of the repository
         <var-prefix>_WC_REVISION - current revision
         <var-prefix>_WC_LAST_CHANGED_AUTHOR - author of last commit
         <var-prefix>_WC_LAST_CHANGED_DATE - date of last commit
         <var-prefix>_WC_LAST_CHANGED_REV - revision of last commit
         <var-prefix>_WC_LAST_CHANGED_LOG - last log of base revision
         <var-prefix>_WC_INFO - output of command `svn info <dir>'

       Example usage:

         FIND_PACKAGE(Subversion)
         IF(Subversion_FOUND)
           Subversion_WC_INFO(${PROJECT_SOURCE_DIR} Project)
           MESSAGE("Current revision is ${Project_WC_REVISION}")
         ENDIF(Subversion_FOUND)


  FindSWIG
       Find SWIG

       This module finds an installed SWIG.  It sets the following variables:

         SWIG_FOUND - set to true if SWIG is found
         SWIG_DIR - the directory where swig is installed
         SWIG_EXECUTABLE - the path to the swig executable


  FindTCL
       Find Tcl includes and libraries.

       This module finds if TCL is installed and determines where the include
       files and libraries are.  It also determines what the name of the
       library is.  This code sets the following variables:

         TCL_LIBRARY        = path to Tcl library (tcl tcl80)
         TCL_LIBRARY_DEBUG  = path to Tcl library (debug)
         TCL_STUB_LIBRARY   = path to Tcl stub library
         TCL_STUB_LIBRARY_DEBUG = path to debug stub library
         TCL_INCLUDE_PATH   = path to where tcl.h can be found
         TCL_TCLSH          = path to tclsh binary (tcl tcl80)
         TK_LIBRARY         = path to Tk library (tk tk80 etc)
         TK_LIBRARY_DEBUG   = path to Tk library (debug)
         TK_STUB_LIBRARY    = path to Tk stub library
         TK_STUB_LIBRARY_DEBUG = path to debug Tk stub library
         TK_INCLUDE_PATH    = path to where tk.h can be found
         TK_INTERNAL_PATH   = path to where tkWinInt.h is found
         TK_WISH            = full path to the wish executable


  FindTclsh
       Find tclsh

       This module finds if TCL is installed and determines where the include
       files and libraries are.  It also determines what the name of the
       library is.  This code sets the following variables:

         TCL_TCLSH = the path to the tclsh executable

       In cygwin, look for the cygwin version first.  Don't look for it later
       to avoid finding the cygwin version on a Win32 build.

  FindThreads
       This module determines the thread library of the system.

       The following variables are set

         CMAKE_THREAD_LIBS_INIT     - the thread library
         CMAKE_USE_SPROC_INIT       - are we using sproc?
         CMAKE_USE_WIN32_THREADS_INIT - using WIN32 threads?
         CMAKE_USE_PTHREADS_INIT    - are we using pthreads
         CMAKE_HP_PTHREADS_INIT     - are we using hp pthreads


  FindTIFF
       Find TIFF library

       Find the native TIFF includes and library This module defines

         TIFF_INCLUDE_DIR, where to find tiff.h, etc.
         TIFF_LIBRARIES, libraries to link against to use TIFF.
         TIFF_FOUND, If false, do not try to use TIFF.

       also defined, but not for general use are

         TIFF_LIBRARY, where to find the TIFF library.


  FindUnixCommands
       Find unix commands from cygwin

       This module looks for some usual Unix commands.


  FindVTK
       Find a VTK installation or build tree.

       The following variables are set if VTK is found.  If VTK is not found,
       VTK_FOUND is set to false.

         VTK_FOUND         - Set to true when VTK is found.
         VTK_USE_FILE      - CMake file to use VTK.
         VTK_MAJOR_VERSION - The VTK major version number.
         VTK_MINOR_VERSION - The VTK minor version number 
                              (odd non-release).
         VTK_BUILD_VERSION - The VTK patch level 
                              (meaningless for odd minor).
         VTK_INCLUDE_DIRS  - Include directories for VTK
         VTK_LIBRARY_DIRS  - Link directories for VTK libraries
         VTK_KITS          - List of VTK kits, in CAPS 
                             (COMMON,IO,) etc.
         VTK_LANGUAGES     - List of wrapped languages, in CAPS
                             (TCL, PYHTON,) etc.

       The following cache entries must be set by the user to locate VTK:

         VTK_DIR  - The directory containing VTKConfig.cmake.  
                    This is either the root of the build tree,
                    or the lib/vtk directory.  This is the 
                    only cache entry.

       The following variables are set for backward compatibility and should
       not be used in new code:

         USE_VTK_FILE - The full path to the UseVTK.cmake file.
                        This is provided for backward 
                        compatibility.  Use VTK_USE_FILE 
                        instead.

       


  FindWget
       Find wget

       This module looks for wget.  This module defines the following values:

         WGET_EXECUTABLE: the full path to the wget tool.
         WGET_FOUND: True if wget has been found.


  FindWish
       Find wish installation

       This module finds if TCL is installed and determines where the include
       files and libraries are.  It also determines what the name of the
       library is.  This code sets the following variables:

         TK_WISH = the path to the wish executable

       

       if UNIX is defined, then it will look for the cygwin version first

  FindwxWidgets
       Find a wxWidgets (a.k.a., wxWindows) installation.

       This module finds if wxWidgets is installed and selects a default
       configuration to use.

       The following variables are searched for and set to defaults in case
       of multiple choices.  Change them if the defaults are not desired:

         wxWidgets_ROOT_DIR      - Base wxWidgets directory
                                   (e.g., C:/wxWidgets-2.6.3).
         wxWidgets_LIB_DIR       - Path to wxWidgets libraries
                                   (e.g., C:/wxWidgets-2.6.3/lib/vc_lib).
         wxWidgets_CONFIGURATION - Configuration to use
                                   (e.g., msw, mswd, mswu, mswunivud, etc.)
         wxWidgets_USE_LIBS      - Libraries to use besides the common
                                   required ones; set to base and core by
                                   default. You couls also list them in
                                   FIND_PACKAGE(wxWidgets REQUIRED
                                                <components>)

       

       The following are set after configuration is done:

         wxWidgets_FOUND            - Set to TRUE if wxWidgets was found.
         wxWidgets_INCLUDE_DIRS     - Include directories for WIN32
                                      i.e., where to find "wx/wx.h" and
                                      "wx/setup.h"; possibly empty for unices.
         wxWidgets_LIBRARIES        - Path to the wxWidgets libraries.
         wxWidgets_LIBRARY_DIRS     - compile time link dirs, useful for
                                      rpath on UNIX. Typically an empty string
                                      in WIN32 environment.
         wxWidgets_DEFINITIONS      - Contains defines required to compile/link
                                      against WX, e.g. -DWXUSINGDLL
         wxWidgets_CXX_FLAGS        - Include dirs and ompiler flags for
                                      unices, empty on WIN32. Esentially
                                      "`wx-config --cxxflags`".
         wxWidgets_USE_FILE         - convenience include file

       

       Sample usage:

          SET(wxWidgets_USE_LIBS base core gl net)
          FIND_PACKAGE(wxWidgets)
          IF(wxWidgets_FOUND)
            INCLUDE(${wxWidgets_USE_FILE})
            # and for each of your dependant executable/library targets:
            TARGET_LINK_LIBRARIES(<YourTarget> ${wxWidgets_LIBRARIES})
          ENDIF(wxWidgets_FOUND)

       

       Sample usage with monolithic wx build:

          SET(wxWidgets_USE_LIBS msw26 expat jpeg gl png regex tiff zlib)
          ...


  FindwxWindows
       Find wxWindows (wxWidgets) installation

       This module finds if wxWindows/wxWidgets is installed and determines
       where the include files and libraries are.  It also determines what
       the name of the library is.  Please note this file is DEPRECATED and
       replaced by FindwxWidgets.cmake.  This code sets the following
       variables:

         
         WXWINDOWS_FOUND     = system has WxWindows 
         WXWINDOWS_LIBRARIES = path to the wxWindows libraries
                               on Unix/Linux with additional 
                               linker flags from 
                               "wx-config --libs"
         CMAKE_WXWINDOWS_CXX_FLAGS  = Compiler flags for wxWindows, 
                                      essentially "`wx-config --cxxflags`"
                                      on Linux
         WXWINDOWS_INCLUDE_DIR      = where to find "wx/wx.h" and "wx/setup.h"
         WXWINDOWS_LINK_DIRECTORIES = link directories, useful for rpath on
                                       Unix
         WXWINDOWS_DEFINITIONS      = extra defines

       

       OPTIONS If you need OpenGL support please

         SET(WXWINDOWS_USE_GL 1) 

       in your CMakeLists.txt *before* you include this file.

         HAVE_ISYSTEM      - true required to replace -I by -isystem on g++

       

       For convenience include Use_wxWindows.cmake in your project's
       CMakeLists.txt using INCLUDE(Use_wxWindows).

       USAGE

         SET(WXWINDOWS_USE_GL 1) 
         FIND_PACKAGE(wxWindows)

       

       NOTES wxWidgets 2.6.x is supported for monolithic builds e.g.
       compiled in wx/build/msw dir as:

         nmake -f makefile.vc BUILD=debug SHARED=0 USE_OPENGL=1 MONOLITHIC=1

       

       DEPRECATED

         CMAKE_WX_CAN_COMPILE
         WXWINDOWS_LIBRARY
         CMAKE_WX_CXX_FLAGS
         WXWINDOWS_INCLUDE_PATH

       

       AUTHOR Jan Woetzel <http://www.mip.informatik.uni-kiel.de/~jw>
       (07/2003-01/2006)

  FindX11
       Find X11 installation

       Try to find X11 on UNIX systems.  The following values are defined

         X11_FOUND        - True if X11 is available
         X11_INCLUDE_DIR  - include directories to use X11
         X11_LIBRARIES    - link against these to use X11


  FindXMLRPC
       Find xmlrpc

       Find the native XMLRPC headers and libraries.

         XMLRPC_INCLUDE_DIRS      - where to find xmlrpc.h, etc.
         XMLRPC_LIBRARIES         - List of libraries when using xmlrpc.
         XMLRPC_FOUND             - True if xmlrpc found.

       XMLRPC modules may be specified as components for this find module.
       Modules may be listed by running "xmlrpc-c-config".  Modules include:

         c++            C++ wrapper code
         libwww-client  libwww-based client
         cgi-server     CGI-based server
         abyss-server   ABYSS-based server

       Typical usage:

         FIND_PACKAGE(XMLRPC REQUIRED libwww-client)


  FindZLIB
       Find zlib

       Find the native ZLIB includes and library

         ZLIB_INCLUDE_DIR - where to find zlib.h, etc.
         ZLIB_LIBRARIES   - List of libraries when using zlib.
         ZLIB_FOUND       - True if zlib found.


  InstallRequiredSystemLibraries
        

       Hack for Visual Studio support Search for system runtime libraries
       based on the platform.  This is not complete because it is used only
       for the release process by the developers.

  MacroAddFileDependencies
       MACRO_ADD_FILE_DEPENDENCIES(<_file> depend_files...)

       MACRO_OPTIONAL_FIND_PACKAGE( <name> [QUIT] )

  TestBigEndian
       Define macro to determine endian type

       Check if the system is big endian or little endian

         TEST_BIG_ENDIAN(VARIABLE)
         VARIABLE - variable to store the result to

       


  TestCXXAcceptsFlag
       Test CXX compiler for a flag

       Check if the CXX compiler accepts a flag

         Macro CHECK_CXX_ACCEPTS_FLAG(FLAGS VARIABLE) -
            checks if the function exists
         FLAGS - the flags to try
         VARIABLE - variable to store the result

       


  TestForANSIForScope
       Check for ANSI for scope support

       Check if the compiler supports std:: on stl classes.

         CMAKE_NO_STD_NAMESPACE - holds result

       


  TestForANSIStreamHeaders
       Test for compiler support of ANSI stream headers iostream, etc.

       check if we they have the standard ansi stream files (without the .h)

         CMAKE_NO_ANSI_STREAM_HEADERS - defined by the results

       


  TestForSSTREAM
        

       # - Test for std:: namespace support check if the compiler supports
       std:: on stl classes

         CMAKE_NO_STD_NAMESPACE - defined by the results

       


  TestForSTDNamespace
       Test for std:: namespace support

       check if the compiler supports std:: on stl classes

         CMAKE_NO_STD_NAMESPACE - defined by the results

       


  UseEcos
       This module defines variables and macros required to build eCos
       application.

       This file contains the following macros:
       ECOS_ADD_INCLUDE_DIRECTORIES() - add the eCos include dirs
       ECOS_ADD_EXECUTABLE(name source1 ...  sourceN ) - create an eCos
       executable ECOS_ADJUST_DIRECTORY(VAR source1 ...  sourceN ) - adjusts
       the path of the source files and puts the result into VAR

       Macros for selecting the toolchain: ECOS_USE_ARM_ELF_TOOLS() - enable
       the ARM ELF toolchain for the directory where it is called
       ECOS_USE_I386_ELF_TOOLS() - enable the i386 ELF toolchain for the
       directory where it is called ECOS_USE_PPC_EABI_TOOLS() - enable the
       PowerPC toolchain for the directory where it is called

       It contains the following variables: ECOS_DEFINITIONS
       ECOSCONFIG_EXECUTABLE for internal use only:

         ECOS_ADD_TARGET_LIB


  UsePkgConfig
       pkg-config module for CMake

       

       Defines the following macros:

       PKGCONFIG(package includedir libdir linkflags cflags)

       Calling PKGCONFIG will fill the desired information into the 4 given
       arguments, e.g.  PKGCONFIG(libart-2.0 LIBART_INCLUDE_DIR
       LIBART_LINK_DIR LIBART_LINK_FLAGS LIBART_CFLAGS) if pkg-config was NOT
       found or the specified software package doesn't exist, the variable
       will be empty when the function returns, otherwise they will contain
       the respective information


  UseQt4
       Use Module for QT4

       Sets up C and C++ to use Qt 4.  It is assumed that FindQt.cmake has
       already been loaded.  See FindQt.cmake for information on how to load
       Qt 4 into your CMake project.

  UseSWIG
       SWIG module for CMake

       Defines the following macros:

          SWIG_ADD_MODULE(name language [ files ])
            - Define swig module with given name and specified language
          SWIG_LINK_LIBRARIES(name [ libraries ])
            - Link libraries to swig module

       All other macros are for internal use only.  To get the actual name of
       the swig module, use: ${SWIG_MODULE_name_REAL_NAME}.  Set Source files
       properties such as CPLUSPLUS and SWIG_FLAGS to specify special
       behavior of SWIG.  Also global CMAKE_SWIG_FLAGS can be used to add
       special flags to all swig calls.  Another special variable is
       CMAKE_SWIG_OUTDIR, it allows one to specify where to write all the
       swig generated module (swig -outdir option) The name-specific variable
       SWIG_MODULE_<name>_EXTRA_DEPS may be used to specify extra
       dependencies for the generated modules.

  UsewxWidgets
       Convenience include for using wxWidgets library

       Finds if wxWidgets is installed and set the appropriate libs, incdirs,
       flags etc.  INCLUDE_DIRECTORIES, LINK_DIRECTORIES and ADD_DEFINITIONS
       are called.

       USAGE

         SET( wxWidgets_USE_LIBS  gl xml xrc ) # optionally: more than wx std libs
         FIND_PACKAGE(wxWidgets REQUIRED)
         INCLUDE( ${xWidgets_USE_FILE} )
         ... add your targets here, e.g. ADD_EXECUTABLE/ ADD_LIBRARY ...
         TARGET_LINK_LIBRARIERS( <yourWxDependantTarget>  ${wxWidgets_LIBRARIES})

       

       DEPRECATED

         LINK_LIBRARIES is not called in favor of adding dependencies per target.

       

       AUTHOR

         Jan Woetzel <jw -at- mip.informatik.uni-kiel.de>


  Use_wxWindows
       ---------------------------------------------------

       

       This convenience include finds if wxWindows is installed and set the
       appropriate libs, incdirs, flags etc.  author Jan Woetzel <jw -at-
       mip.informatik.uni-kiel.de> (07/2003)

       USAGE:

          just include Use_wxWindows.cmake 
          in your projects CMakeLists.txt

       INCLUDE( ${CMAKE_MODULE_PATH}/Use_wxWindows.cmake)

       if you are sure you need GL then

         SET(WXWINDOWS_USE_GL 1)

       *before* you include this file.

       16.Feb.2004: changed INCLUDE to FIND_PACKAGE to read from users own
       non-system CMAKE_MODULE_PATH (Jan Woetzel JW) 07/2006: rewrite as
       FindwxWidgets.cmake, kept for backward compatibilty JW

------------------------------------------------------------------------------
Copyright

Copyright (c) 2002 Kitware, Inc., Insight Consortium.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

       Redistributions of source code must retain the above copyright notice,
       this list of conditions and the following disclaimer.

       Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in the
       documentation and/or other materials provided with the distribution.

       The names of Kitware, Inc., the Insight Consortium, or the names of
       any consortium members, or of any contributors, may not be used to
       endorse or promote products derived from this software without
       specific prior written permission.

       Modified source versions must be plainly marked as such, and must not
       be misrepresented as being the original software.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

------------------------------------------------------------------------------
See Also

The following resources are available to get help using CMake:

  Home Page
       http://www.cmake.org

       The primary starting point for learning about CMake.

  Frequently Asked Questions
       http://www.cmake.org/Wiki/CMake_FAQ

       A Wiki is provided containing answers to frequently asked questions.

  Online Documentation
       http://www.cmake.org/HTML/Documentation.html

       Links to available documentation may be found on this web page.

  Mailing List
       http://www.cmake.org/HTML/MailingLists.html

       For help and discussion about using cmake, a mailing list is provided
       at cmake@cmake.org.  The list is member-post-only but one may sign up
       on the CMake web page.  Please first read the full documentation at
       http://www.cmake.org before posting questions to the list.

Summary of helpful links:

  Home: http://www.cmake.org
  Docs: http://www.cmake.org/HTML/Documentation.html
  Mail: http://www.cmake.org/HTML/MailingLists.html
  FAQ:  http://www.cmake.org/Wiki/CMake_FAQ


